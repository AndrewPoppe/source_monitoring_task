ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
V/Volumes/Macintosh HD/Users/poppe076/Desktop/source_monitoring_task/data/ok_source_monitoring_2015_Feb_05_1353
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'source_monitoring'
p11
sS'dataNames'
p12
(lp13
S'choice'
p14
asS'autoLog'
p15
I01
sS'extraInfo'
p16
(dp17
S'participant'
p18
Vok
p19
sS'listOrder'
p20
(lp21
V1
aV1
aV1
aV1
aV1
aV1
aV1
aV1
aV1
asS'frameRate'
p22
cnumpy.core.multiarray
scalar
p23
(cnumpy
dtype
p24
(S'f8'
I0
I1
tRp25
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x1a\x98`-\xbc\xf6M@'
tRp26
sS'expName'
p27
g11
sS'date'
p28
V2015_Feb_05_1353
p29
sS'listMethod'
p30
Vset your own
p31
ssS'loopsUnfinished'
p32
(lp33
sS'saveWideText'
p34
I01
sS'thisEntry'
p35
(dp36
sS'version'
p37
S''
sS'_paramNamesSoFar'
p38
(lp39
S'word'
p40
aS'amount'
p41
aS'list'
p42
aS'trialtype'
p43
aS'trialtype_extended'
p44
asS'entries'
p45
(lp46
(dp47
S'trials.thisIndex'
p48
g23
(g24
(S'i4'
I0
I1
tRp49
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00\x00\x00\x00'
tRp50
sg22
g26
sg40
Vword2.1
p51
sS'trials.thisRepN'
p52
I0
sg42
Vlist2
p53
sg44
Vpitch_lower_large
p54
sS'trials.thisN'
p55
I0
sg30
g31
sg41
V-1.5
p56
sg27
g11
sS'trials.thisTrialN'
p57
I0
sg43
Vpitch
p58
sg20
g21
sg28
g29
sg18
g19
sg14
S'self'
p59
sa(dp60
S'trials.thisIndex'
p61
g23
(g49
S'\x01\x00\x00\x00'
tRp62
sg22
g26
sg40
Vword2.1
p63
sS'trials.thisRepN'
p64
I0
sg42
Vlist2
p65
sg44
Vunmodified
p66
sS'trials.thisN'
p67
I1
sg30
g31
sg41
Vunmodified
p68
sg27
g11
sS'trials.thisTrialN'
p69
I1
sg43
Vunmodified
p70
sg20
g21
sg28
g29
sg18
g19
sg14
g59
sa(dp71
S'trials.thisIndex'
p72
g23
(g49
S'\x02\x00\x00\x00'
tRp73
sg22
g26
sg40
Vword2.1
p74
sS'trials.thisRepN'
p75
I0
sg42
Vlist2
p76
sg44
Vpitch_higher_large
p77
sS'trials.thisN'
p78
I2
sg30
g31
sg41
V2
sg27
g11
sS'trials.thisTrialN'
p79
I2
sg43
Vpitch
p80
sg20
g21
sg28
g29
sg18
g19
sg14
g59
sa(dp81
S'trials.thisIndex'
p82
g23
(g49
S'\x03\x00\x00\x00'
tRp83
sg22
g26
sg40
Vword2.1
p84
sS'trials.thisRepN'
p85
I0
sg42
Vlist2
p86
sg44
Vslow_small
p87
sS'trials.thisN'
p88
I3
sg30
g31
sg41
V0.9
p89
sg27
g11
sS'trials.thisTrialN'
p90
I3
sg43
Vspeed
p91
sg20
g21
sg28
g29
sg18
g19
sg14
g59
sa(dp92
S'trials.thisIndex'
p93
g23
(g49
S'\x04\x00\x00\x00'
tRp94
sg22
g26
sg40
Vword2.1
p95
sS'trials.thisRepN'
p96
I0
sg42
Vlist2
p97
sg44
Vpitch_lower_small
p98
sS'trials.thisN'
p99
I4
sg30
g31
sg41
V-1.5
p100
sg27
g11
sS'trials.thisTrialN'
p101
I4
sg43
Vpitch
p102
sg20
g21
sg28
g29
sg18
g19
sg14
g59
sa(dp103
S'trials.thisIndex'
p104
g23
(g49
S'\x05\x00\x00\x00'
tRp105
sg22
g26
sg40
Vword2.1
p106
sS'trials.thisRepN'
p107
I0
sg42
Vlist2
p108
sg44
Vslow_large
p109
sS'trials.thisN'
p110
I5
sg30
g31
sg41
V0.7
p111
sg27
g11
sS'trials.thisTrialN'
p112
I5
sg43
Vspeed
p113
sg20
g21
sg28
g29
sg18
g19
sg14
g59
sa(dp114
S'trials.thisIndex'
p115
g23
(g49
S'\x06\x00\x00\x00'
tRp116
sg22
g26
sg40
Vword2.1
p117
sS'trials.thisRepN'
p118
I0
sg42
Vlist2
p119
sg44
Vslow_medium
p120
sS'trials.thisN'
p121
I6
sg30
g31
sg41
V0.8
p122
sg27
g11
sS'trials.thisTrialN'
p123
I6
sg43
Vspeed
p124
sg20
g21
sg28
g29
sg18
g19
sg14
g59
sa(dp125
S'trials.thisIndex'
p126
g23
(g49
S'\x07\x00\x00\x00'
tRp127
sg22
g26
sg40
Vword2.1
p128
sS'trials.thisRepN'
p129
I0
sg42
Vlist2
p130
sg44
Vunmodified
p131
sS'trials.thisN'
p132
I7
sg30
g31
sg41
Vunmodified
p133
sg27
g11
sS'trials.thisTrialN'
p134
I7
sg43
Vunmodified
p135
sg20
g21
sg28
g29
sg18
g19
sg14
g59
sa(dp136
S'trials.thisIndex'
p137
g23
(g49
S'\x08\x00\x00\x00'
tRp138
sg22
g26
sg40
Vword2.1
p139
sS'trials.thisRepN'
p140
I0
sg42
Vlist2
p141
sg44
Vpitch_higher_small
p142
sS'trials.thisN'
p143
I8
sg30
g31
sg41
V1.5
p144
sg27
g11
sS'trials.thisTrialN'
p145
I8
sg43
Vpitch
p146
sg20
g21
sg28
g29
sg18
g19
sg14
g59
sasS'loops'
p147
(lp148
g1
(cpsychopy.data
TrialHandler
p149
g3
NtRp150
(dp151
S'origin'
p152
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.03), Thu Feb  5 12:37:35 2015\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'source_monitoring'  # from the Builder filename that created this script\u000aexpInfo = {}\u000a\u000amyDlg = gui.Dlg(title=expName, size=gui.wx.Size(-1,-75))\u000amyDlg.addField(u'participant: ', u'')\u000amyDlg.addField('word lists: ', choices=['random','set your own']) \u000amyDlg.show()\u000aif myDlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['participant'] = myDlg.data[0]\u000aexpInfo['listMethod'] = myDlg.data[1]\u000aprint expInfo['listMethod']\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a\u000aif expInfo['listMethod']=='set your own':\u000a    myDlg2 = gui.Dlg(title='Set Word Lists')\u000a    conditions = ['unmodified 1', 'unmodified 2', 'slowed - small', 'slowed - medium', 'slowed - large', 'pitch - higher - small', 'pitch - higher - large', 'pitch - lower - small', 'pitch - lower - large']\u000a    for cNum in range(len(conditions)):\u000a        myDlg2.addField(conditions[cNum], choices=[1,2,3,4,5,6,7,8,9], initial=cNum+1)\u000a    myDlg2.show()\u000a    if myDlg2.OK == False: core.quit()  # user pressed cancel\u000a    expInfo['listOrder'] = myDlg2.data\u000a    \u000afrom psychopy import visual\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1440, 900), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[-1,-1,-1], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "initialize_code"\u000ainitialize_codeClock = core.Clock()\u000afrom psychopy import gui\u000afrom pyo import *\u000aimport math, sys, csv, random\u000afrom collections import OrderedDict\u000aserv = Server().boot()\u000a\u000a## SETTINGS ##\u000a\u000aSPEED_SMALL_AMOUNT = .9   #0.975\u000aSPEED_MEDIUM_AMOUNT = .8  #0.95\u000aSPEED_LARGE_AMOUNT = .7   #0.925\u000aPITCH_HIGHER_SMALL_AMOUNT = 1.5    #0.5\u000aPITCH_HIGHER_LARGE_AMOUNT = 2    #1.0\u000aPITCH_LOWER_SMALL_AMOUNT = -1.5 #-0.5\u000aPITCH_LOWER_LARGE_AMOUNT = -2 #-1.0\u000a\u000aSELF_BOX_FILL_COLOR = '#A6A9FF'\u000aSELF_BOX_BORDER_COLOR = '#3E45FA'\u000aOTHER_BOX_FILL_COLOR = '#FFFCA6'\u000aOTHER_BOX_BORDER_COLOR = '#FAF33E'\u000a\u000a## END SETTINGS ##\u000a\u000a\u000a\u000a\u000a\u000a# initialize this variable - it keeps track of whether \u000a# the subject is finished speaking during a time stretch trial\u000afinished = True\u000a\u000a##########################################################\u000a### read in the original word list file and save word list file for this subject\u000a##########################################################\u000a# container array for file contents\u000aorig_words = []\u000a# read csv file with the original word lists (in same directory as this experiment script)\u000awith open('orig_words.csv', 'rU') as csvfile:\u000a    test = csv.reader(csvfile)\u000a    for i in test:\u000a        orig_words.append(i)\u000a\u000a# for now, assignment of list to trial type is random\u000a# need to write method for letting experimenter choose assignment at run time\u000aif expInfo['listMethod']=='set your own':\u000a    assignment_order = map(int, expInfo['listOrder'])\u000aelse:\u000a    assignment_order = random.sample([0,1,2,3,4,5,6,7,8], 9)\u000a\u000a# initialize word containers for the trial types\u000aunmodified_words1 = []\u000aunmodified_words2 = []\u000aslowed_small_words = []\u000aslowed_medium_words = []\u000aslowed_large_words = []\u000apitch_higher_small_words = []\u000apitch_higher_large_words = []\u000apitch_lower_small_words = []\u000apitch_lower_large_words = []\u000a\u000a# assign words to those containers\u000afor row in orig_words:\u000a    unmodified_words1.append(row[assignment_order[0]])\u000a    unmodified_words2.append(row[assignment_order[1]])\u000a    slowed_small_words.append(row[assignment_order[2]])\u000a    slowed_medium_words.append(row[assignment_order[3]])\u000a    slowed_large_words.append(row[assignment_order[4]])\u000a    pitch_higher_small_words.append(row[assignment_order[5]])\u000a    pitch_higher_large_words.append(row[assignment_order[6]])\u000a    pitch_lower_small_words.append(row[assignment_order[7]])\u000a    pitch_lower_large_words.append(row[assignment_order[8]])\u000a\u000a# this will be the name of the wordlist csv file for this subject\u000awordlist_filename = filename+'_wordlist.csv'\u000aresults_filename = filename+'_summarized_results.csv'\u000a\u000a# build a big array with all the words and also attach trialtype and amount data,\u000a# like this: [word, trialtype, trialtype_extended, amount, list]\u000amaster_list = []\u000a\u000a# add the words (CAREFUL! This assumes all of the categories are of equal length)\u000afor word_index in range(len(slowed_small_words)):\u000a    if word_index == 0:\u000a        continue\u000a    master_list.append([unmodified_words1[word_index], 'unmodified', 'unmodified',            'unmodified',                                        unmodified_words1[0]])\u000a    master_list.append([unmodified_words2[word_index], 'unmodified', 'unmodified',            'unmodified',                                        unmodified_words2[0]])\u000a    master_list.append([slowed_small_words[word_index],         'speed', 'slow_small',           SPEED_SMALL_AMOUNT,                slowed_small_words[0]])\u000a    master_list.append([slowed_medium_words[word_index],     'speed', 'slow_medium',       SPEED_MEDIUM_AMOUNT,             slowed_medium_words[0]])\u000a    master_list.append([slowed_large_words[word_index],         'speed', 'slow_large',             SPEED_LARGE_AMOUNT,               slowed_large_words[0]])\u000a    master_list.append([pitch_higher_small_words[word_index], 'pitch',  'pitch_higher_small', PITCH_HIGHER_SMALL_AMOUNT,  pitch_higher_small_words[0]])\u000a    master_list.append([pitch_higher_large_words[word_index], 'pitch',  'pitch_higher_large',  PITCH_HIGHER_LARGE_AMOUNT, pitch_higher_large_words[0]])\u000a    master_list.append([pitch_lower_small_words[word_index],  'pitch',  'pitch_lower_small',   PITCH_LOWER_SMALL_AMOUNT,  pitch_lower_small_words[0]])\u000a    master_list.append([pitch_lower_large_words[word_index],  'pitch',  'pitch_lower_large',    PITCH_LOWER_SMALL_AMOUNT,  pitch_lower_large_words[0]])\u000a\u000a# now randomize the list\u000arandom.shuffle(master_list)\u000a\u000a# save csv file to disk\u000awith open(wordlist_filename,'wb') as w:\u000a    writer=csv.writer(w)\u000a    writer.writerow(['word','trialtype', 'trialtype_extended', 'amount', 'list'])\u000a    for row in master_list:\u000a        writer.writerow(row)\u000a\u000a# create container for stats\u000achoice_stats = OrderedDict()\u000achoice_stats['unmodified'] = []\u000achoice_stats['slow_small'] = []\u000achoice_stats['slow_medium'] = []\u000achoice_stats['slow_large'] = []\u000achoice_stats['pitch_higher_small'] = []\u000achoice_stats['pitch_higher_large'] = []\u000achoice_stats['pitch_lower_small'] = []\u000achoice_stats['pitch_lower_large'] = []\u000a\u000a# Initialize components for Routine "instructions"\u000ainstructionsClock = core.Clock()\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='Instructions will go here.',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aserv.start()\u000amic = Input(chnl=0)\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "choose_source"\u000achoose_sourceClock = core.Clock()\u000aquestion = visual.TextStim(win=win, ori=0, name='question',\u000a    text='Whose voice did you hear?',    font='Arial',\u000a    pos=[0, .5], height=0.1, wrapWidth=2,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000aself_box = visual.Rect(win=win, name='self_box',\u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-.5, -.5],\u000a    lineWidth=5, lineColor=SELF_BOX_BORDER_COLOR, lineColorSpace='rgb',\u000a    fillColor=SELF_BOX_FILL_COLOR, fillColorSpace='rgb',\u000a    opacity=1,interpolate=True)\u000aself_label = visual.TextStim(win=win, ori=0, name='self_label',\u000a    text='Mine',    font='Arial',\u000a    pos=[-.5, -.5], height=0.1, wrapWidth=None,\u000a    color='black', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000aother_box = visual.Rect(win=win, name='other_box',\u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[.5, -.5],\u000a    lineWidth=5, lineColor=OTHER_BOX_BORDER_COLOR, lineColorSpace='rgb',\u000a    fillColor=OTHER_BOX_FILL_COLOR, fillColorSpace='rgb',\u000a    opacity=1,interpolate=True)\u000aother_label = visual.TextStim(win=win, ori=0, name='other_label',\u000a    text='Other',    font='Arial',\u000a    pos=[.5, -.5], height=0.1, wrapWidth=None,\u000a    color='black', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000amouse = event.Mouse(win=win)\u000ax, y = [None, None]\u000a\u000a\u000a# Initialize components for Routine "thankyou"\u000athankyouClock = core.Clock()\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='Thank you for participating!',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "display_results"\u000adisplay_resultsClock = core.Clock()\u000aresults_text = visual.TextStim(win=win, ori=0, name='results_text',\u000a    text='default text',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=2,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "initialize_code"-------\u000at = 0\u000ainitialize_codeClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000ainitialize_codeComponents = []\u000afor thisComponent in initialize_codeComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "initialize_code"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = initialize_codeClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in initialize_codeComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "initialize_code"-------\u000afor thisComponent in initialize_codeComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a#------Prepare to start Routine "instructions"-------\u000at = 0\u000ainstructionsClock.reset()  # clock \u000aframeN = -1\u000aroutineTimer.add(5.000000)\u000a# update component parameters for each repeat\u000a# keep track of which components have finished\u000ainstructionsComponents = []\u000ainstructionsComponents.append(text_4)\u000afor thisComponent in instructionsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instructions"-------\u000acontinueRoutine = True\u000awhile continueRoutine and routineTimer.getTime() > 0:\u000a    # get current time\u000a    t = instructionsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_4* updates\u000a    if t >= 0.0 and text_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_4.tStart = t  # underestimates by a little under one frame\u000a        text_4.frameNStart = frameN  # exact frame index\u000a        text_4.setAutoDraw(True)\u000a    if text_4.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        text_4.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instructions"-------\u000afor thisComponent in instructionsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atrials = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(wordlist_filename),\u000a    seed=None, name='trials')\u000athisExp.addLoop(trials)  # add the loop to the experiment\u000athisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000aif thisTrial != None:\u000a    for paramName in thisTrial.keys():\u000a        exec(paramName + '= thisTrial.' + paramName)\u000a\u000afor thisTrial in trials:\u000a    currentLoop = trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(11.000000)\u000a    # update component parameters for each repeat\u000a    if(trialtype == "pitch"): # pitch trial\u000a        b = Harmonizer(mic, transpo=float(amount))\u000a        c = Gate(b, thresh=-90, falltime=0.02, lookahead=20.0).mix(2).out()\u000a        d = Follower2(b)\u000a        talkThresh = .08\u000a        talkStarted = False\u000a        stoppedTalking = False\u000a        stopTime = 100\u000a    elif(trialtype == 'speed'): # speed trial\u000a        finished = 'not finished'\u000a        playback_speed = float(amount)\u000a        dur = 2\u000a        if playback_speed == 0:\u000a            playback_speed = pow(10,-100)\u000a    \u000a        def start():\u000a            rec.play()\u000a            a.play().out()\u000a            tf.stop()\u000a    \u000a        def stop():\u000a            k.stop()\u000a            global finished\u000a            finished = 'finished'\u000a            a.stop()\u000a            a.reset()\u000a            tf.play()\u000a    \u000a        tab = NewTable(dur, chnls=2)\u000a        transpo_to_normal = math.log(1.0 / playback_speed, 2) * 12\u000a        j = Harmonizer(mic, transpo=transpo_to_normal).mix(2)\u000a        k = Gate(j, thresh=-70, falltime=0.02, lookahead=20.0)\u000a        rec = TableRec(k, tab)\u000a        a = TableRead(table=tab, freq=playback_speed/dur).stop()\u000a        env = Follower(mic)\u000a        th = Thresh(env, .1)\u000a        tf = TrigFunc(th, start)\u000a        tr = TrigFunc(rec['trig'], stop)\u000a    else: # unmodified trial\u000a        b = Gate(mic, thresh=-90, falltime=0.02, lookahead=20.0).mix(2).out()\u000a        d = Follower2(mic)\u000a        talkThresh = .08\u000a        talkStarted = False\u000a        stoppedTalking = False\u000a        stopTime = 100\u000a    text.setText(word)\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(text)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        if(trialtype == "pitch" or trialtype == "unmodified"):\u000a            if d.get() > talkThresh:\u000a                    talkStarted = True\u000a        \u000a            if talkStarted and not stoppedTalking:\u000a                if d.get() < talkThresh:\u000a                    stoppedTalking = True\u000a                    stopTime = globalClock.getTime() + 1\u000a        \u000a            if stoppedTalking and globalClock.getTime() >= stopTime:\u000a                b.stop()\u000a                for thisComponent in trialComponents:\u000a                    if hasattr(thisComponent, "status"):\u000a                        thisComponent.status = FINISHED\u000a                    continueRoutine = False\u000a        else:\u000a            if(finished == 'finished'):\u000a                for thisComponent in trialComponents:\u000a                    if hasattr(thisComponent, "status"):\u000a                        thisComponent.status = FINISHED\u000a                    continueRoutine = False\u000a        \u000a        # *text* updates\u000a        if t >= 1 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        if text.status == STARTED and t >= (1 + (10-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    \u000a    #------Prepare to start Routine "choose_source"-------\u000a    t = 0\u000a    choose_sourceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # setup some python lists for storing info about the mouse\u000a    \u000a    # keep track of which components have finished\u000a    choose_sourceComponents = []\u000a    choose_sourceComponents.append(question)\u000a    choose_sourceComponents.append(self_box)\u000a    choose_sourceComponents.append(self_label)\u000a    choose_sourceComponents.append(other_box)\u000a    choose_sourceComponents.append(other_label)\u000a    choose_sourceComponents.append(mouse)\u000a    for thisComponent in choose_sourceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "choose_source"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = choose_sourceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *question* updates\u000a        if t >= 0.0 and question.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            question.tStart = t  # underestimates by a little under one frame\u000a            question.frameNStart = frameN  # exact frame index\u000a            question.setAutoDraw(True)\u000a        \u000a        # *self_box* updates\u000a        if t >= 0.0 and self_box.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            self_box.tStart = t  # underestimates by a little under one frame\u000a            self_box.frameNStart = frameN  # exact frame index\u000a            self_box.setAutoDraw(True)\u000a        \u000a        # *self_label* updates\u000a        if t >= 0.0 and self_label.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            self_label.tStart = t  # underestimates by a little under one frame\u000a            self_label.frameNStart = frameN  # exact frame index\u000a            self_label.setAutoDraw(True)\u000a        \u000a        # *other_box* updates\u000a        if t >= 0.0 and other_box.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            other_box.tStart = t  # underestimates by a little under one frame\u000a            other_box.frameNStart = frameN  # exact frame index\u000a            other_box.setAutoDraw(True)\u000a        \u000a        # *other_label* updates\u000a        if t >= 0.0 and other_label.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            other_label.tStart = t  # underestimates by a little under one frame\u000a            other_label.frameNStart = frameN  # exact frame index\u000a            other_label.setAutoDraw(True)\u000a        if mouse.isPressedIn(self_box, buttons=[0]):\u000a            trials.addData('choice', 'self')\u000a            choice_stats[trialtype_extended].append(1)\u000a            for thisComponent in trialComponents:\u000a                    if hasattr(thisComponent, "status"):\u000a                        thisComponent.status = FINISHED\u000a                    continueRoutine = False\u000a        elif mouse.isPressedIn(other_box, buttons=[0]):\u000a            trials.addData('choice','other')\u000a            choice_stats[trialtype_extended].append(0)\u000a            for thisComponent in trialComponents:\u000a                    if hasattr(thisComponent, "status"):\u000a                        thisComponent.status = FINISHED\u000a                    continueRoutine = False\u000a        \u000a        if self_box.contains(mouse):\u000a            self_box.fillColor = SELF_BOX_BORDER_COLOR\u000a        else:\u000a            self_box.fillColor = SELF_BOX_FILL_COLOR\u000a        \u000a        if other_box.contains(mouse):\u000a            other_box.fillColor = OTHER_BOX_BORDER_COLOR\u000a        else:\u000a            other_box.fillColor = OTHER_BOX_FILL_COLOR\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choose_sourceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "choose_source"-------\u000a    for thisComponent in choose_sourceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for trials (TrialHandler)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'trials'\u000a\u000a\u000a#------Prepare to start Routine "thankyou"-------\u000at = 0\u000athankyouClock.reset()  # clock \u000aframeN = -1\u000aroutineTimer.add(5.000000)\u000a# update component parameters for each repeat\u000a# calculate mean of stats\u000achoice_means = OrderedDict()\u000afor ttype in choice_stats:\u000a    choice_means[ttype] = np.mean(choice_stats[ttype])\u000a\u000a\u000a# keep track of which components have finished\u000athankyouComponents = []\u000athankyouComponents.append(text_3)\u000afor thisComponent in thankyouComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thankyou"-------\u000acontinueRoutine = True\u000awhile continueRoutine and routineTimer.getTime() > 0:\u000a    # get current time\u000a    t = thankyouClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_3* updates\u000a    if t >= 0.0 and text_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_3.tStart = t  # underestimates by a little under one frame\u000a        text_3.frameNStart = frameN  # exact frame index\u000a        text_3.setAutoDraw(True)\u000a    if text_3.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        text_3.setAutoDraw(False)\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankyouComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "thankyou"-------\u000afor thisComponent in thankyouComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#win.close()\u000a#myDlg = gui.Dlg(title="Results", size=gui.wx.Size(-200,-200))\u000a#for ttype in choice_means:\u000a#    selfValue = "%.2f" % (choice_means[ttype] * 100.0)\u000a#    otherValue = "%.2f" % (100 - choice_means[ttype] * 100.0)\u000a#    myDlg.addText(ttype+': '+selfValue+'% self, '+otherValue+'% other')\u000a#myDlg.show()\u000a\u000a#core.quit()\u000a\u000aresults = '\u005cn\u005cr'\u000afor ttype in choice_means:\u000a    selfValue = "%.2f" % (choice_means[ttype] * 100.0)\u000a    otherValue = "%.2f" % (100 - choice_means[ttype] * 100.0)\u000a    results += ttype+': '+selfValue+'% self, '+otherValue+'% other'+'\u005cn\u005cr'\u000a\u000a# write summarized results to csv file\u000awith open(results_filename,'wb') as w:\u000a    writer=csv.writer(w)\u000a    writer.writerow(['trialtype', 'percent_self_choices', 'percent_other_choices'])\u000a    for row in choice_means:\u000a        selfValue = "%.2f" % (choice_means[ttype] * 100.0)\u000a        otherValue = "%.2f" % (100 - choice_means[ttype] * 100.0)\u000a        writer.writerow([row, selfValue, otherValue])\u000a\u000a#------Prepare to start Routine "display_results"-------\u000at = 0\u000adisplay_resultsClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aresults_text.setText(results)\u000akey_resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_2.status = NOT_STARTED\u000a# keep track of which components have finished\u000adisplay_resultsComponents = []\u000adisplay_resultsComponents.append(results_text)\u000adisplay_resultsComponents.append(key_resp_2)\u000afor thisComponent in display_resultsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "display_results"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = display_resultsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *results_text* updates\u000a    if t >= 0.0 and results_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        results_text.tStart = t  # underestimates by a little under one frame\u000a        results_text.frameNStart = frameN  # exact frame index\u000a        results_text.setAutoDraw(True)\u000a    \u000a    # *key_resp_2* updates\u000a    if t >= 0.0 and key_resp_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_2.frameNStart = frameN  # exact frame index\u000a        key_resp_2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['esc'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in display_resultsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "display_results"-------\u000afor thisComponent in display_resultsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000aserv.stop()\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p153
sS'thisTrial'
p154
(lp155
sS'_exp'
p156
I104483120
sg10
S'trials'
p157
sg6
S'/Volumes/Macintosh HD/Users/poppe076/Desktop/source_monitoring_task/source_monitoring.py'
p158
sS'thisRepN'
p159
I1
sg15
I01
sg16
g17
sS'data'
p160
g1
(cpsychopy.data
DataHandler
p161
c__builtin__
dict
p162
(dp163
S'ran'
p164
cnumpy.ma.core
_mareconstruct
p165
(cnumpy.ma.core
MaskedArray
p166
cnumpy
ndarray
p167
(I0
tp168
S'b'
tRp169
(I1
(I9
I1
tg24
(S'f4'
I0
I1
tRp170
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p171
g165
(g166
g167
g168
S'b'
tRp172
(I1
(I9
I1
tg170
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@\x00\x00\xa0@\x00\x00\xc0@\x00\x00\xe0@\x00\x00\x00A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg14
cnumpy.core.multiarray
_reconstruct
p173
(g167
(I0
tS'b'
tRp174
(I1
(I9
I1
tg24
(S'O4'
I0
I1
tRp175
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp176
g59
ag59
ag59
ag59
ag59
ag59
ag59
ag59
ag59
atbstRp177
(dp178
S'isNumeric'
p179
(dp180
g164
I01
sg171
I01
sg14
I00
ssg157
g150
sS'dataTypes'
p181
(lp182
g164
ag171
ag14
asS'dataShape'
p183
(lp184
I9
aI1
asbsS'method'
p185
S'sequential'
p186
sS'sequenceIndices'
p187
g173
(g167
(I0
tS'b'
tRp188
(I1
(I9
I1
tg49
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00'
tbsS'finished'
p189
I01
sS'nReps'
p190
I1
sS'nRemaining'
p191
I-1
sS'trialList'
p192
(lp193
g1
(cpsychopy.data
TrialType
p194
g162
(dp195
g42
g53
sg41
g56
sg40
g51
sg43
g58
sg44
g54
stRp196
ag1
(g194
g162
(dp197
g42
g65
sg41
g68
sg40
g63
sg43
g70
sg44
g66
stRp198
ag1
(g194
g162
(dp199
g42
g76
sg41
V2
sg40
g74
sg43
g80
sg44
g77
stRp200
ag1
(g194
g162
(dp201
g42
g86
sg41
g89
sg40
g84
sg43
g91
sg44
g87
stRp202
ag1
(g194
g162
(dp203
g42
g97
sg41
g100
sg40
g95
sg43
g102
sg44
g98
stRp204
ag1
(g194
g162
(dp205
g42
g108
sg41
g111
sg40
g106
sg43
g113
sg44
g109
stRp206
ag1
(g194
g162
(dp207
g42
g119
sg41
g122
sg40
g117
sg43
g124
sg44
g120
stRp208
ag1
(g194
g162
(dp209
g42
g130
sg41
g133
sg40
g128
sg43
g135
sg44
g131
stRp210
ag1
(g194
g162
(dp211
g42
g141
sg41
g144
sg40
g139
sg43
g146
sg44
g142
stRp212
asS'seed'
p213
NsS'thisIndex'
p214
g138
sS'thisN'
p215
I9
sS'thisTrialN'
p216
I0
sS'nTotal'
p217
I9
sS'_warnUseOfNext'
p218
I01
sbasS'savePickle'
p219
I01
sb.