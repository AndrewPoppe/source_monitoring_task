ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
V/Volumes/Macintosh HD/Users/poppe076/Desktop/source_monitoring_task/data/ok_source_monitoring_2015_Jun_24_1113
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'source_monitoring'
p11
sS'dataNames'
p12
(lp13
S'choice'
p14
asS'autoLog'
p15
I01
sS'extraInfo'
p16
(dp17
S'participant'
p18
Vok
p19
sS'listOrder'
p20
(lp21
V1
aV2
aV3
aV4
aV5
aV6
aV7
aV8
aV9
asS'frameRate'
p22
NsS'expName'
p23
g11
sS'date'
p24
V2015_Jun_24_1113
p25
sS'listMethod'
p26
Vset your own
p27
ssS'loopsUnfinished'
p28
(lp29
g1
(cpsychopy.data
TrialHandler
p30
g3
NtRp31
(dp32
S'origin'
p33
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.03), Thu Feb  5 12:37:35 2015\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'source_monitoring'  # from the Builder filename that created this script\u000aexpInfo = {}\u000a\u000amyDlg = gui.Dlg(title=expName, size=gui.wx.Size(-1,-75))\u000amyDlg.addField(u'participant: ', u'')\u000amyDlg.addField('word lists: ', choices=['random','set your own']) \u000amyDlg.show()\u000aif myDlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['participant'] = myDlg.data[0]\u000aexpInfo['listMethod'] = myDlg.data[1]\u000aprint expInfo['listMethod']\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a\u000aif expInfo['listMethod']=='set your own':\u000a    myDlg2 = gui.Dlg(title='Set Word Lists')\u000a    conditions = ['unmodified 1', 'unmodified 2', 'slowed - small', 'slowed - medium', 'slowed - large', 'pitch - higher - small', 'pitch - higher - large', 'pitch - lower - small', 'pitch - lower - large']\u000a    for cNum in range(len(conditions)):\u000a        myDlg2.addField(conditions[cNum], choices=[1,2,3,4,5,6,7,8,9], initial=cNum+1)\u000a    myDlg2.show()\u000a    if myDlg2.OK == False: core.quit()  # user pressed cancel\u000a    expInfo['listOrder'] = myDlg2.data\u000a    \u000afrom psychopy import visual\u000a\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1440, 900), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[-1,-1,-1], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "initialize_code"\u000ainitialize_codeClock = core.Clock()\u000afrom psychopy import gui\u000afrom pyo import *\u000aimport math, sys, csv, random\u000afrom collections import OrderedDict\u000aserv = Server().boot()\u000a\u000a## SETTINGS ##\u000a\u000aSPEED_SMALL_AMOUNT = .9   #0.975\u000aSPEED_MEDIUM_AMOUNT = .8  #0.95\u000aSPEED_LARGE_AMOUNT = .7   #0.925\u000aPITCH_HIGHER_SMALL_AMOUNT = 1.5    #0.5\u000aPITCH_HIGHER_LARGE_AMOUNT = 2    #1.0\u000aPITCH_LOWER_SMALL_AMOUNT = -1.5 #-0.5\u000aPITCH_LOWER_LARGE_AMOUNT = -2 #-1.0\u000a\u000aSELF_BOX_FILL_COLOR = '#A6A9FF'\u000aSELF_BOX_BORDER_COLOR = '#3E45FA'\u000aOTHER_BOX_FILL_COLOR = '#FFFCA6'\u000aOTHER_BOX_BORDER_COLOR = '#FAF33E'\u000a\u000a## END SETTINGS ##\u000a\u000a\u000a\u000a\u000a\u000a# initialize this variable - it keeps track of whether \u000a# the subject is finished speaking during a time stretch trial\u000afinished = True\u000a\u000a##########################################################\u000a### read in the original word list file and save word list file for this subject\u000a##########################################################\u000a# container array for file contents\u000aorig_words = []\u000a# read csv file with the original word lists (in same directory as this experiment script)\u000awith open('orig_words.csv', 'rU') as csvfile:\u000a    test = csv.reader(csvfile)\u000a    for i in test:\u000a        orig_words.append(i)\u000a\u000a# depending on experiementer's selection at run time, either randomize word lists or\u000a# use the experimenter's order\u000adef fixList(x):\u000a    return int(x)-1\u000a\u000aif expInfo['listMethod']=='set your own':\u000a    assignment_order = map(fixList, expInfo['listOrder'])\u000aelse:\u000a    assignment_order = random.sample([0,1,2,3,4,5,6,7,8], 9)\u000a\u000a# initialize word containers for the trial types\u000aunmodified_words1 = []\u000aunmodified_words2 = []\u000aslowed_small_words = []\u000aslowed_medium_words = []\u000aslowed_large_words = []\u000apitch_higher_small_words = []\u000apitch_higher_large_words = []\u000apitch_lower_small_words = []\u000apitch_lower_large_words = []\u000a\u000a# assign words to those containers\u000afor row in orig_words:\u000a    unmodified_words1.append(row[assignment_order[0]])\u000a    unmodified_words2.append(row[assignment_order[1]])\u000a    slowed_small_words.append(row[assignment_order[2]])\u000a    slowed_medium_words.append(row[assignment_order[3]])\u000a    slowed_large_words.append(row[assignment_order[4]])\u000a    pitch_higher_small_words.append(row[assignment_order[5]])\u000a    pitch_higher_large_words.append(row[assignment_order[6]])\u000a    pitch_lower_small_words.append(row[assignment_order[7]])\u000a    pitch_lower_large_words.append(row[assignment_order[8]])\u000a\u000a# this will be the name of the wordlist csv file for this subject\u000awordlist_filename = filename+'_wordlist.csv'\u000aresults_filename = filename+'_summarized_results.csv'\u000a\u000a# build a big array with all the words and also attach trialtype and amount data,\u000a# like this: [word, trialtype, trialtype_extended, amount, list]\u000amaster_list = []\u000a\u000a# add the words (CAREFUL! This assumes all of the categories are of equal length)\u000afor word_index in range(len(slowed_small_words)):\u000a    if word_index == 0:\u000a        continue\u000a    master_list.append([unmodified_words1[word_index], 'unmodified', 'unmodified',            'unmodified',                                        unmodified_words1[0]])\u000a    master_list.append([unmodified_words2[word_index], 'unmodified', 'unmodified',            'unmodified',                                        unmodified_words2[0]])\u000a    master_list.append([slowed_small_words[word_index],         'speed', 'slow_small',           SPEED_SMALL_AMOUNT,                slowed_small_words[0]])\u000a    master_list.append([slowed_medium_words[word_index],     'speed', 'slow_medium',       SPEED_MEDIUM_AMOUNT,             slowed_medium_words[0]])\u000a    master_list.append([slowed_large_words[word_index],         'speed', 'slow_large',             SPEED_LARGE_AMOUNT,               slowed_large_words[0]])\u000a    master_list.append([pitch_higher_small_words[word_index], 'pitch',  'pitch_higher_small', PITCH_HIGHER_SMALL_AMOUNT,  pitch_higher_small_words[0]])\u000a    master_list.append([pitch_higher_large_words[word_index], 'pitch',  'pitch_higher_large',  PITCH_HIGHER_LARGE_AMOUNT, pitch_higher_large_words[0]])\u000a    master_list.append([pitch_lower_small_words[word_index],  'pitch',  'pitch_lower_small',   PITCH_LOWER_SMALL_AMOUNT,  pitch_lower_small_words[0]])\u000a    master_list.append([pitch_lower_large_words[word_index],  'pitch',  'pitch_lower_large',    PITCH_LOWER_SMALL_AMOUNT,  pitch_lower_large_words[0]])\u000a\u000a# now randomize the list\u000arandom.shuffle(master_list)\u000a\u000a# save csv file to disk\u000awith open(wordlist_filename,'wb') as w:\u000a    writer=csv.writer(w)\u000a    writer.writerow(['word','trialtype', 'trialtype_extended', 'amount', 'list'])\u000a    for row in master_list:\u000a        writer.writerow(row)\u000a\u000a# create container for stats\u000achoice_stats = OrderedDict()\u000achoice_stats['unmodified'] = []\u000achoice_stats['slow_small'] = []\u000achoice_stats['slow_medium'] = []\u000achoice_stats['slow_large'] = []\u000achoice_stats['pitch_higher_small'] = []\u000achoice_stats['pitch_higher_large'] = []\u000achoice_stats['pitch_lower_small'] = []\u000achoice_stats['pitch_lower_large'] = []\u000a\u000a# Initialize components for Routine "instructions"\u000ainstructionsClock = core.Clock()\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='Instructions will go here.',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aserv.start()\u000amic = Input(chnl=0)\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "choose_source"\u000achoose_sourceClock = core.Clock()\u000aquestion = visual.TextStim(win=win, ori=0, name='question',\u000a    text='Whose voice did you hear?',    font='Arial',\u000a    pos=[0, .5], height=0.1, wrapWidth=2,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000aself_box = visual.Rect(win=win, name='self_box',\u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-.5, -.5],\u000a    lineWidth=5, lineColor=SELF_BOX_BORDER_COLOR, lineColorSpace='rgb',\u000a    fillColor=SELF_BOX_FILL_COLOR, fillColorSpace='rgb',\u000a    opacity=1,interpolate=True)\u000aself_label = visual.TextStim(win=win, ori=0, name='self_label',\u000a    text='Mine',    font='Arial',\u000a    pos=[-.5, -.5], height=0.1, wrapWidth=None,\u000a    color='black', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000aother_box = visual.Rect(win=win, name='other_box',\u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[.5, -.5],\u000a    lineWidth=5, lineColor=OTHER_BOX_BORDER_COLOR, lineColorSpace='rgb',\u000a    fillColor=OTHER_BOX_FILL_COLOR, fillColorSpace='rgb',\u000a    opacity=1,interpolate=True)\u000aother_label = visual.TextStim(win=win, ori=0, name='other_label',\u000a    text='Other',    font='Arial',\u000a    pos=[.5, -.5], height=0.1, wrapWidth=None,\u000a    color='black', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000amouse = event.Mouse(win=win)\u000ax, y = [None, None]\u000a\u000a\u000a# Initialize components for Routine "thankyou"\u000athankyouClock = core.Clock()\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='Thank you for participating!',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "display_results"\u000adisplay_resultsClock = core.Clock()\u000aresults_text = visual.TextStim(win=win, ori=0, name='results_text',\u000a    text='default text',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=2,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "initialize_code"-------\u000at = 0\u000ainitialize_codeClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000ainitialize_codeComponents = []\u000afor thisComponent in initialize_codeComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "initialize_code"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = initialize_codeClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in initialize_codeComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "initialize_code"-------\u000afor thisComponent in initialize_codeComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a#------Prepare to start Routine "instructions"-------\u000at = 0\u000ainstructionsClock.reset()  # clock \u000aframeN = -1\u000aroutineTimer.add(5.000000)\u000a# update component parameters for each repeat\u000a# keep track of which components have finished\u000ainstructionsComponents = []\u000ainstructionsComponents.append(text_4)\u000afor thisComponent in instructionsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instructions"-------\u000acontinueRoutine = True\u000awhile continueRoutine and routineTimer.getTime() > 0:\u000a    # get current time\u000a    t = instructionsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_4* updates\u000a    if t >= 0.0 and text_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_4.tStart = t  # underestimates by a little under one frame\u000a        text_4.frameNStart = frameN  # exact frame index\u000a        text_4.setAutoDraw(True)\u000a    if text_4.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        text_4.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instructions"-------\u000afor thisComponent in instructionsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atrials = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(wordlist_filename),\u000a    seed=None, name='trials')\u000athisExp.addLoop(trials)  # add the loop to the experiment\u000athisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000aif thisTrial != None:\u000a    for paramName in thisTrial.keys():\u000a        exec(paramName + '= thisTrial.' + paramName)\u000a\u000afor thisTrial in trials:\u000a    currentLoop = trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(11.000000)\u000a    # update component parameters for each repeat\u000a    if(trialtype == "pitch"): # pitch trial\u000a        b = Harmonizer(mic, transpo=float(amount))\u000a        c = Gate(b, thresh=-90, falltime=0.02, lookahead=20.0).mix(2).out()\u000a        d = Follower2(b)\u000a        talkThresh = .08\u000a        talkStarted = False\u000a        stoppedTalking = False\u000a        stopTime = 100\u000a    elif(trialtype == 'speed'): # speed trial\u000a        finished = 'not finished'\u000a        playback_speed = float(amount)\u000a        dur = 2\u000a        if playback_speed == 0:\u000a            playback_speed = pow(10,-100)\u000a    \u000a        def start():\u000a            rec.play()\u000a            a.play().out()\u000a            tf.stop()\u000a    \u000a        def stop():\u000a            k.stop()\u000a            global finished\u000a            finished = 'finished'\u000a            a.stop()\u000a            a.reset()\u000a            tf.play()\u000a    \u000a        tab = NewTable(dur, chnls=2)\u000a        transpo_to_normal = math.log(1.0 / playback_speed, 2) * 12\u000a        j = Harmonizer(mic, transpo=transpo_to_normal).mix(2)\u000a        k = Gate(j, thresh=-70, falltime=0.02, lookahead=20.0)\u000a        rec = TableRec(k, tab)\u000a        a = TableRead(table=tab, freq=playback_speed/dur).stop()\u000a        env = Follower(mic)\u000a        th = Thresh(env, .1)\u000a        tf = TrigFunc(th, start)\u000a        tr = TrigFunc(rec['trig'], stop)\u000a    else: # unmodified trial\u000a        b = Gate(mic, thresh=-90, falltime=0.02, lookahead=20.0).mix(2).out()\u000a        d = Follower2(mic)\u000a        talkThresh = .08\u000a        talkStarted = False\u000a        stoppedTalking = False\u000a        stopTime = 100\u000a    text.setText(word)\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(text)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        if(trialtype == "pitch" or trialtype == "unmodified"):\u000a            if d.get() > talkThresh:\u000a                    talkStarted = True\u000a        \u000a            if talkStarted and not stoppedTalking:\u000a                if d.get() < talkThresh:\u000a                    stoppedTalking = True\u000a                    stopTime = globalClock.getTime() + 1\u000a        \u000a            if stoppedTalking and globalClock.getTime() >= stopTime:\u000a                b.stop()\u000a                for thisComponent in trialComponents:\u000a                    if hasattr(thisComponent, "status"):\u000a                        thisComponent.status = FINISHED\u000a                    continueRoutine = False\u000a        else:\u000a            if(finished == 'finished'):\u000a                for thisComponent in trialComponents:\u000a                    if hasattr(thisComponent, "status"):\u000a                        thisComponent.status = FINISHED\u000a                    continueRoutine = False\u000a        \u000a        # *text* updates\u000a        if t >= 1 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        if text.status == STARTED and t >= (1 + (10-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    \u000a    #------Prepare to start Routine "choose_source"-------\u000a    t = 0\u000a    choose_sourceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # setup some python lists for storing info about the mouse\u000a    \u000a    # keep track of which components have finished\u000a    choose_sourceComponents = []\u000a    choose_sourceComponents.append(question)\u000a    choose_sourceComponents.append(self_box)\u000a    choose_sourceComponents.append(self_label)\u000a    choose_sourceComponents.append(other_box)\u000a    choose_sourceComponents.append(other_label)\u000a    choose_sourceComponents.append(mouse)\u000a    for thisComponent in choose_sourceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "choose_source"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = choose_sourceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *question* updates\u000a        if t >= 0.0 and question.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            question.tStart = t  # underestimates by a little under one frame\u000a            question.frameNStart = frameN  # exact frame index\u000a            question.setAutoDraw(True)\u000a        \u000a        # *self_box* updates\u000a        if t >= 0.0 and self_box.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            self_box.tStart = t  # underestimates by a little under one frame\u000a            self_box.frameNStart = frameN  # exact frame index\u000a            self_box.setAutoDraw(True)\u000a        \u000a        # *self_label* updates\u000a        if t >= 0.0 and self_label.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            self_label.tStart = t  # underestimates by a little under one frame\u000a            self_label.frameNStart = frameN  # exact frame index\u000a            self_label.setAutoDraw(True)\u000a        \u000a        # *other_box* updates\u000a        if t >= 0.0 and other_box.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            other_box.tStart = t  # underestimates by a little under one frame\u000a            other_box.frameNStart = frameN  # exact frame index\u000a            other_box.setAutoDraw(True)\u000a        \u000a        # *other_label* updates\u000a        if t >= 0.0 and other_label.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            other_label.tStart = t  # underestimates by a little under one frame\u000a            other_label.frameNStart = frameN  # exact frame index\u000a            other_label.setAutoDraw(True)\u000a        if mouse.isPressedIn(self_box, buttons=[0]):\u000a            trials.addData('choice', 'self')\u000a            choice_stats[trialtype_extended].append(1)\u000a            for thisComponent in trialComponents:\u000a                    if hasattr(thisComponent, "status"):\u000a                        thisComponent.status = FINISHED\u000a                    continueRoutine = False\u000a        elif mouse.isPressedIn(other_box, buttons=[0]):\u000a            trials.addData('choice','other')\u000a            choice_stats[trialtype_extended].append(0)\u000a            for thisComponent in trialComponents:\u000a                    if hasattr(thisComponent, "status"):\u000a                        thisComponent.status = FINISHED\u000a                    continueRoutine = False\u000a        \u000a        if self_box.contains(mouse):\u000a            self_box.fillColor = SELF_BOX_BORDER_COLOR\u000a        else:\u000a            self_box.fillColor = SELF_BOX_FILL_COLOR\u000a        \u000a        if other_box.contains(mouse):\u000a            other_box.fillColor = OTHER_BOX_BORDER_COLOR\u000a        else:\u000a            other_box.fillColor = OTHER_BOX_FILL_COLOR\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choose_sourceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "choose_source"-------\u000a    for thisComponent in choose_sourceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for trials (TrialHandler)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'trials'\u000a\u000a\u000a#------Prepare to start Routine "thankyou"-------\u000at = 0\u000athankyouClock.reset()  # clock \u000aframeN = -1\u000aroutineTimer.add(5.000000)\u000a# update component parameters for each repeat\u000a# calculate mean of stats\u000achoice_means = OrderedDict()\u000afor ttype in choice_stats:\u000a    choice_means[ttype] = np.mean(choice_stats[ttype])\u000a\u000a\u000a# keep track of which components have finished\u000athankyouComponents = []\u000athankyouComponents.append(text_3)\u000afor thisComponent in thankyouComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thankyou"-------\u000acontinueRoutine = True\u000awhile continueRoutine and routineTimer.getTime() > 0:\u000a    # get current time\u000a    t = thankyouClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_3* updates\u000a    if t >= 0.0 and text_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_3.tStart = t  # underestimates by a little under one frame\u000a        text_3.frameNStart = frameN  # exact frame index\u000a        text_3.setAutoDraw(True)\u000a    if text_3.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        text_3.setAutoDraw(False)\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankyouComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "thankyou"-------\u000afor thisComponent in thankyouComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#win.close()\u000a#myDlg = gui.Dlg(title="Results", size=gui.wx.Size(-200,-200))\u000a#for ttype in choice_means:\u000a#    selfValue = "%.2f" % (choice_means[ttype] * 100.0)\u000a#    otherValue = "%.2f" % (100 - choice_means[ttype] * 100.0)\u000a#    myDlg.addText(ttype+': '+selfValue+'% self, '+otherValue+'% other')\u000a#myDlg.show()\u000a\u000a#core.quit()\u000a\u000aresults = '\u005cn\u005cr'\u000afor ttype in choice_means:\u000a    selfValue = "%.2f" % (choice_means[ttype] * 100.0)\u000a    otherValue = "%.2f" % (100 - choice_means[ttype] * 100.0)\u000a    results += ttype+': '+selfValue+'% self, '+otherValue+'% other'+'\u005cn\u005cr'\u000a\u000a# write summarized results to csv file\u000awith open(results_filename,'wb') as w:\u000a    writer=csv.writer(w)\u000a    writer.writerow(['trialtype', 'percent_self_choices', 'percent_other_choices'])\u000a    for row in choice_means:\u000a        selfValue = "%.2f" % (choice_means[row] * 100.0)\u000a        otherValue = "%.2f" % (100 - choice_means[row] * 100.0)\u000a        writer.writerow([row, selfValue, otherValue])\u000a\u000a#------Prepare to start Routine "display_results"-------\u000at = 0\u000adisplay_resultsClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aresults_text.setText(results)\u000akey_resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_2.status = NOT_STARTED\u000a# keep track of which components have finished\u000adisplay_resultsComponents = []\u000adisplay_resultsComponents.append(results_text)\u000adisplay_resultsComponents.append(key_resp_2)\u000afor thisComponent in display_resultsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "display_results"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = display_resultsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *results_text* updates\u000a    if t >= 0.0 and results_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        results_text.tStart = t  # underestimates by a little under one frame\u000a        results_text.frameNStart = frameN  # exact frame index\u000a        results_text.setAutoDraw(True)\u000a    \u000a    # *key_resp_2* updates\u000a    if t >= 0.0 and key_resp_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_2.frameNStart = frameN  # exact frame index\u000a        key_resp_2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['esc'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in display_resultsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "display_results"-------\u000afor thisComponent in display_resultsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000aserv.stop()\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p34
sS'thisTrial'
p35
g1
(cpsychopy.data
TrialType
p36
c__builtin__
dict
p37
(dp38
S'list'
p39
Vlist5
p40
sS'amount'
p41
V0.7
p42
sS'word'
p43
Vword5.1
p44
sS'trialtype'
p45
Vspeed
p46
sS'trialtype_extended'
p47
Vslow_large
p48
stRp49
sS'_exp'
p50
I157115504
sg10
S'trials'
p51
sg6
S'/Volumes/Macintosh HD/Users/poppe076/Desktop/source_monitoring_task/source_monitoring.py'
p52
sS'thisRepN'
p53
I0
sg15
I01
sg16
g17
sS'data'
p54
g1
(cpsychopy.data
DataHandler
p55
g37
(dp56
S'ran'
p57
cnumpy.ma.core
_mareconstruct
p58
(cnumpy.ma.core
MaskedArray
p59
cnumpy
ndarray
p60
(I0
tp61
S'b'
tRp62
(I1
(I9
I1
tcnumpy
dtype
p63
(S'f4'
I0
I1
tRp64
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p65
g58
(g59
g60
g61
S'b'
tRp66
(I1
(I9
I1
tg64
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x01\x01\x01\x01\x01'
Ntbsg14
cnumpy.core.multiarray
_reconstruct
p67
(g60
(I0
tS'b'
tRp68
(I1
(I9
I1
tg63
(S'O4'
I0
I1
tRp69
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp70
S'self'
p71
ag71
aS'other'
p72
aS'--'
p73
aS'--'
p74
aS'--'
p75
aS'--'
p76
aS'--'
p77
aS'--'
p78
atbstRp79
(dp80
S'isNumeric'
p81
(dp82
g57
I01
sg65
I01
sg14
I00
ssg51
g31
sS'dataTypes'
p83
(lp84
g57
ag65
ag14
asS'dataShape'
p85
(lp86
I9
aI1
asbsS'method'
p87
S'sequential'
p88
sS'sequenceIndices'
p89
g67
(g60
(I0
tS'b'
tRp90
(I1
(I9
I1
tg63
(S'i4'
I0
I1
tRp91
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00'
tbsS'finished'
p92
I00
sS'nReps'
p93
I1
sS'nRemaining'
p94
I5
sS'trialList'
p95
(lp96
g1
(g36
g37
(dp97
g39
Vlist6
p98
sg41
V1.5
p99
sg43
Vword6.1
p100
sg45
Vpitch
p101
sg47
Vpitch_higher_small
p102
stRp103
ag1
(g36
g37
(dp104
g39
Vlist1
p105
sg41
Vunmodified
p106
sg43
Vword1.1
p107
sg45
Vunmodified
p108
sg47
Vunmodified
p109
stRp110
ag1
(g36
g37
(dp111
g39
Vlist9
p112
sg41
V-1.5
p113
sg43
Vword9.1
p114
sg45
Vpitch
p115
sg47
Vpitch_lower_large
p116
stRp117
ag49
ag1
(g36
g37
(dp118
g39
Vlist3
p119
sg41
V0.9
p120
sg43
Vword3.1
p121
sg45
Vspeed
p122
sg47
Vslow_small
p123
stRp124
ag1
(g36
g37
(dp125
g39
Vlist2
p126
sg41
Vunmodified
p127
sg43
Vword2.1
p128
sg45
Vunmodified
p129
sg47
Vunmodified
p130
stRp131
ag1
(g36
g37
(dp132
g39
Vlist8
p133
sg41
V-1.5
p134
sg43
Vword8.1
p135
sg45
Vpitch
p136
sg47
Vpitch_lower_small
p137
stRp138
ag1
(g36
g37
(dp139
g39
Vlist7
p140
sg41
V2
sg43
Vword7.1
p141
sg45
Vpitch
p142
sg47
Vpitch_higher_large
p143
stRp144
ag1
(g36
g37
(dp145
g39
Vlist4
p146
sg41
V0.8
p147
sg43
Vword4.1
p148
sg45
Vspeed
p149
sg47
Vslow_medium
p150
stRp151
asS'seed'
p152
NsS'thisIndex'
p153
cnumpy.core.multiarray
scalar
p154
(g91
S'\x03\x00\x00\x00'
tRp155
sS'thisN'
p156
I3
sS'thisTrialN'
p157
I3
sS'nTotal'
p158
I9
sS'_warnUseOfNext'
p159
I01
sbasS'saveWideText'
p160
I01
sS'thisEntry'
p161
(dp162
sS'version'
p163
S''
sS'_paramNamesSoFar'
p164
(lp165
g43
ag41
ag39
ag45
ag47
asS'entries'
p166
(lp167
(dp168
S'trials.thisIndex'
p169
g154
(g91
S'\x00\x00\x00\x00'
tRp170
sg22
Nsg43
g100
sS'trials.thisRepN'
p171
I0
sg39
g98
sg47
g102
sS'trials.thisN'
p172
I0
sg26
g27
sg41
g99
sg23
g11
sS'trials.thisTrialN'
p173
I0
sg45
g101
sg20
g21
sg24
g25
sg18
g19
sg14
g71
sa(dp174
S'trials.thisIndex'
p175
g154
(g91
S'\x01\x00\x00\x00'
tRp176
sg22
Nsg43
g107
sS'trials.thisRepN'
p177
I0
sg39
g105
sg47
g109
sS'trials.thisN'
p178
I1
sg26
g27
sg41
g106
sg23
g11
sS'trials.thisTrialN'
p179
I1
sg45
g108
sg20
g21
sg24
g25
sg18
g19
sg14
g71
sa(dp180
S'trials.thisIndex'
p181
g154
(g91
S'\x02\x00\x00\x00'
tRp182
sg22
Nsg43
g114
sS'trials.thisRepN'
p183
I0
sg39
g112
sg47
g116
sS'trials.thisN'
p184
I2
sg26
g27
sg41
g113
sg23
g11
sS'trials.thisTrialN'
p185
I2
sg45
g115
sg20
g21
sg24
g25
sg18
g19
sg14
g72
sasS'loops'
p186
(lp187
g31
asS'savePickle'
p188
I01
sb.