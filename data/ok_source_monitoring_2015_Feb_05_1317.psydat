ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
V/Volumes/Macintosh HD/Users/poppe076/Desktop/source_monitoring_task/data/ok_source_monitoring_2015_Feb_05_1317
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'source_monitoring'
p11
sS'dataNames'
p12
(lp13
sS'autoLog'
p14
I01
sS'extraInfo'
p15
(dp16
S'participant'
p17
Vok
p18
sS'listOrder'
p19
(lp20
V1
aV2
aV3
aV4
aV5
aV6
aV7
aV8
aV9
asS'frameRate'
p21
cnumpy.core.multiarray
scalar
p22
(cnumpy
dtype
p23
(S'f8'
I0
I1
tRp24
(I3
S'<'
NNNI-1
I-1
I0
tbS'\xe9)\xfb\xa6\xe0\xf6M@'
tRp25
sS'expName'
p26
g11
sS'date'
p27
V2015_Feb_05_1317
p28
sS'listMethod'
p29
Vset your own
p30
ssS'loopsUnfinished'
p31
(lp32
g1
(cpsychopy.data
TrialHandler
p33
g3
NtRp34
(dp35
S'origin'
p36
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.03), Thu Feb  5 12:37:35 2015\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'source_monitoring'  # from the Builder filename that created this script\u000aexpInfo = {}\u000a\u000amyDlg = gui.Dlg(title=expName, size=gui.wx.Size(-1,-75))\u000amyDlg.addField(u'participant: ', u'')\u000amyDlg.addField('word lists: ', choices=['random','set your own']) \u000amyDlg.show()\u000aif myDlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['participant'] = myDlg.data[0]\u000aexpInfo['listMethod'] = myDlg.data[1]\u000aprint expInfo['listMethod']\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a\u000aif expInfo['listMethod']=='set your own':\u000a    myDlg2 = gui.Dlg(title='Set Word Lists')\u000a    conditions = ['unmodified 1', 'unmodified 2', 'slowed - small', 'slowed - medium', 'slowed - large', 'pitch - higher - small', 'pitch - higher - large', 'pitch - lower - small', 'pitch - lower - large']\u000a    for cNum in range(len(conditions)):\u000a        myDlg2.addField(conditions[cNum], choices=[1,2,3,4,5,6,7,8,9], initial=cNum+1)\u000a    myDlg2.show()\u000a    if myDlg2.OK == False: core.quit()  # user pressed cancel\u000a    expInfo['listOrder'] = myDlg2.data\u000a    \u000afrom psychopy import visual\u000a\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1440, 900), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[-1,-1,-1], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "initialize_code"\u000ainitialize_codeClock = core.Clock()\u000afrom psychopy import gui\u000afrom pyo import *\u000aimport math, sys, csv, random\u000aserv = Server().boot()\u000a\u000a## SETTINGS ##\u000a\u000aSPEED_SMALL_AMOUNT = .9   #0.975\u000aSPEED_MEDIUM_AMOUNT = .8  #0.95\u000aSPEED_LARGE_AMOUNT = .7   #0.925\u000aPITCH_HIGHER_SMALL_AMOUNT = 1.5    #0.5\u000aPITCH_HIGHER_LARGE_AMOUNT = 2    #1.0\u000aPITCH_LOWER_SMALL_AMOUNT = -1.5 #-0.5\u000aPITCH_LOWER_LARGE_AMOUNT = -2 #-1.0\u000a\u000aSELF_BOX_FILL_COLOR = '#A6A9FF'\u000aSELF_BOX_BORDER_COLOR = '#3E45FA'\u000aOTHER_BOX_FILL_COLOR = '#FFFCA6'\u000aOTHER_BOX_BORDER_COLOR = '#FAF33E'\u000a\u000a## END SETTINGS ##\u000a\u000a\u000a\u000a\u000a\u000a# initialize this variable - it keeps track of whether \u000a# the subject is finished speaking during a time stretch trial\u000afinished = True\u000a\u000a##########################################################\u000a### read in the original word list file and save word list file for this subject\u000a##########################################################\u000a# container array for file contents\u000aorig_words = []\u000a# read csv file with the original word lists (in same directory as this experiment script)\u000awith open('orig_words.csv', 'rU') as csvfile:\u000a    test = csv.reader(csvfile)\u000a    for i in test:\u000a        orig_words.append(i)\u000a\u000a# for now, assignment of list to trial type is random\u000a# need to write method for letting experimenter choose assignment at run time\u000aassignment_order = random.sample([0,1,2,3,4,5,6,7,8], 9)\u000a\u000a# initialize word containers for the trial types\u000aunmodified_words1 = []\u000aunmodified_words2 = []\u000aslowed_small_words = []\u000aslowed_medium_words = []\u000aslowed_large_words = []\u000apitch_higher_small_words = []\u000apitch_higher_large_words = []\u000apitch_lower_small_words = []\u000apitch_lower_large_words = []\u000a\u000a# assign words to those containers\u000afor row in orig_words:\u000a    unmodified_words1.append(row[assignment_order[0]])\u000a    unmodified_words2.append(row[assignment_order[1]])\u000a    slowed_small_words.append(row[assignment_order[2]])\u000a    slowed_medium_words.append(row[assignment_order[3]])\u000a    slowed_large_words.append(row[assignment_order[4]])\u000a    pitch_higher_small_words.append(row[assignment_order[5]])\u000a    pitch_higher_large_words.append(row[assignment_order[6]])\u000a    pitch_lower_small_words.append(row[assignment_order[7]])\u000a    pitch_lower_large_words.append(row[assignment_order[8]])\u000a\u000a# this will be the name of the wordlist csv file for this subject\u000awordlist_filename = filename+'_wordlist.csv'\u000a\u000a# build a big array with all the words and also attach trialtype and amount data,\u000a# like this: [word, trialtype, trialtype_extended, amount, list]\u000amaster_list = []\u000a\u000a# add the words (CAREFUL! This assumes all of the categories are of equal length)\u000afor word_index in range(len(slowed_small_words)):\u000a    if word_index == 0:\u000a        continue\u000a    master_list.append([unmodified_words1[word_index], 'unmodified', 'unmodified',            'unmodified',                                        unmodified_words1[0]])\u000a    master_list.append([unmodified_words2[word_index], 'unmodified', 'unmodified',            'unmodified',                                        unmodified_words2[0]])\u000a    master_list.append([slowed_small_words[word_index],         'speed', 'slow_small',           SPEED_SMALL_AMOUNT,                slowed_small_words[0]])\u000a    master_list.append([slowed_medium_words[word_index],     'speed', 'slow_medium',       SPEED_MEDIUM_AMOUNT,             slowed_medium_words[0]])\u000a    master_list.append([slowed_large_words[word_index],         'speed', 'slow_large',             SPEED_LARGE_AMOUNT,               slowed_large_words[0]])\u000a    master_list.append([pitch_higher_small_words[word_index], 'pitch',  'pitch_higher_small', PITCH_HIGHER_SMALL_AMOUNT,  pitch_higher_small_words[0]])\u000a    master_list.append([pitch_higher_large_words[word_index], 'pitch',  'pitch_higher_large',  PITCH_HIGHER_LARGE_AMOUNT, pitch_higher_large_words[0]])\u000a    master_list.append([pitch_lower_small_words[word_index],  'pitch',  'pitch_lower_small',   PITCH_LOWER_SMALL_AMOUNT,  pitch_lower_small_words[0]])\u000a    master_list.append([pitch_lower_large_words[word_index],  'pitch',  'pitch_lower_large',    PITCH_LOWER_SMALL_AMOUNT,  pitch_lower_large_words[0]])\u000a\u000a# now randomize the list\u000arandom.shuffle(master_list)\u000a\u000a# save csv file to disk\u000awith open(wordlist_filename,'wb') as w:\u000a    writer=csv.writer(w)\u000a    writer.writerow(['word','trialtype', 'trialtype_extended', 'amount', 'list'])\u000a    for row in master_list:\u000a        writer.writerow(row)\u000a\u000a# create container for stats\u000achoice_stats = {}\u000achoice_stats['unmodified'] = []\u000achoice_stats['slow_small'] = []\u000achoice_stats['slow_medium'] = []\u000achoice_stats['slow_large'] = []\u000achoice_stats['pitch_higher_small'] = []\u000achoice_stats['pitch_higher_large'] = []\u000achoice_stats['pitch_lower_small'] = []\u000achoice_stats['pitch_lower_large'] = []\u000a\u000a# Initialize components for Routine "instructions"\u000ainstructionsClock = core.Clock()\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='Instructions will go here.',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aserv.start()\u000amic = Input(chnl=0)\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "choose_source"\u000achoose_sourceClock = core.Clock()\u000aquestion = visual.TextStim(win=win, ori=0, name='question',\u000a    text='Whose voice did you hear?',    font='Arial',\u000a    pos=[0, .5], height=0.1, wrapWidth=2,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000aself_box = visual.Rect(win=win, name='self_box',\u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-.5, -.5],\u000a    lineWidth=5, lineColor=SELF_BOX_BORDER_COLOR, lineColorSpace='rgb',\u000a    fillColor=SELF_BOX_FILL_COLOR, fillColorSpace='rgb',\u000a    opacity=1,interpolate=True)\u000aself_label = visual.TextStim(win=win, ori=0, name='self_label',\u000a    text='Mine',    font='Arial',\u000a    pos=[-.5, -.5], height=0.1, wrapWidth=None,\u000a    color='black', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000aother_box = visual.Rect(win=win, name='other_box',\u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[.5, -.5],\u000a    lineWidth=5, lineColor=OTHER_BOX_BORDER_COLOR, lineColorSpace='rgb',\u000a    fillColor=OTHER_BOX_FILL_COLOR, fillColorSpace='rgb',\u000a    opacity=1,interpolate=True)\u000aother_label = visual.TextStim(win=win, ori=0, name='other_label',\u000a    text='Other',    font='Arial',\u000a    pos=[.5, -.5], height=0.1, wrapWidth=None,\u000a    color='black', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000amouse = event.Mouse(win=win)\u000ax, y = [None, None]\u000a\u000a\u000a# Initialize components for Routine "thankyou"\u000athankyouClock = core.Clock()\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='Thank you for participating!',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "initialize_code"-------\u000at = 0\u000ainitialize_codeClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000ainitialize_codeComponents = []\u000afor thisComponent in initialize_codeComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "initialize_code"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = initialize_codeClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in initialize_codeComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "initialize_code"-------\u000afor thisComponent in initialize_codeComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a#------Prepare to start Routine "instructions"-------\u000at = 0\u000ainstructionsClock.reset()  # clock \u000aframeN = -1\u000aroutineTimer.add(5.000000)\u000a# update component parameters for each repeat\u000a# keep track of which components have finished\u000ainstructionsComponents = []\u000ainstructionsComponents.append(text_4)\u000afor thisComponent in instructionsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instructions"-------\u000acontinueRoutine = True\u000awhile continueRoutine and routineTimer.getTime() > 0:\u000a    # get current time\u000a    t = instructionsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_4* updates\u000a    if t >= 0.0 and text_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_4.tStart = t  # underestimates by a little under one frame\u000a        text_4.frameNStart = frameN  # exact frame index\u000a        text_4.setAutoDraw(True)\u000a    if text_4.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        text_4.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instructions"-------\u000afor thisComponent in instructionsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atrials = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(wordlist_filename),\u000a    seed=None, name='trials')\u000athisExp.addLoop(trials)  # add the loop to the experiment\u000athisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000aif thisTrial != None:\u000a    for paramName in thisTrial.keys():\u000a        exec(paramName + '= thisTrial.' + paramName)\u000a\u000afor thisTrial in trials:\u000a    currentLoop = trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(11.000000)\u000a    # update component parameters for each repeat\u000a    if(trialtype == "pitch"): # pitch trial\u000a        b = Harmonizer(mic, transpo=float(amount))\u000a        c = Gate(b, thresh=-90, falltime=0.02, lookahead=20.0).mix(2).out()\u000a        d = Follower2(b)\u000a        talkThresh = .08\u000a        talkStarted = False\u000a        stoppedTalking = False\u000a        stopTime = 100\u000a    elif(trialtype == 'speed'): # speed trial\u000a        finished = 'not finished'\u000a        playback_speed = float(amount)\u000a        dur = 2\u000a        if playback_speed == 0:\u000a            playback_speed = pow(10,-100)\u000a    \u000a        def start():\u000a            rec.play()\u000a            a.play().out()\u000a            tf.stop()\u000a    \u000a        def stop():\u000a            k.stop()\u000a            global finished\u000a            finished = 'finished'\u000a            a.stop()\u000a            a.reset()\u000a            tf.play()\u000a    \u000a        tab = NewTable(dur, chnls=2)\u000a        transpo_to_normal = math.log(1.0 / playback_speed, 2) * 12\u000a        j = Harmonizer(mic, transpo=transpo_to_normal).mix(2)\u000a        k = Gate(j, thresh=-70, falltime=0.02, lookahead=20.0)\u000a        rec = TableRec(k, tab)\u000a        a = TableRead(table=tab, freq=playback_speed/dur).stop()\u000a        env = Follower(mic)\u000a        th = Thresh(env, .3)\u000a        tf = TrigFunc(th, start)\u000a        tr = TrigFunc(rec['trig'], stop)\u000a    else: # unmodified trial\u000a        b = Gate(mic, thresh=-90, falltime=0.02, lookahead=20.0).mix(2).out()\u000a        d = Follower2(mic)\u000a        talkThresh = .08\u000a        talkStarted = False\u000a        stoppedTalking = False\u000a        stopTime = 100\u000a    text.setText(word)\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(text)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        if(trialtype == "pitch" or trialtype == "unmodified"):\u000a            if d.get() > talkThresh:\u000a                    talkStarted = True\u000a        \u000a            if talkStarted and not stoppedTalking:\u000a                if d.get() < talkThresh:\u000a                    stoppedTalking = True\u000a                    stopTime = globalClock.getTime() + 1\u000a        \u000a            if stoppedTalking and globalClock.getTime() >= stopTime:\u000a                b.stop()\u000a                for thisComponent in trialComponents:\u000a                    if hasattr(thisComponent, "status"):\u000a                        thisComponent.status = FINISHED\u000a                    continueRoutine = False\u000a        else:\u000a            if(finished == 'finished'):\u000a                for thisComponent in trialComponents:\u000a                    if hasattr(thisComponent, "status"):\u000a                        thisComponent.status = FINISHED\u000a                    continueRoutine = False\u000a        \u000a        # *text* updates\u000a        if t >= 1 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        if text.status == STARTED and t >= (1 + (10-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    \u000a    #------Prepare to start Routine "choose_source"-------\u000a    t = 0\u000a    choose_sourceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # setup some python lists for storing info about the mouse\u000a    \u000a    # keep track of which components have finished\u000a    choose_sourceComponents = []\u000a    choose_sourceComponents.append(question)\u000a    choose_sourceComponents.append(self_box)\u000a    choose_sourceComponents.append(self_label)\u000a    choose_sourceComponents.append(other_box)\u000a    choose_sourceComponents.append(other_label)\u000a    choose_sourceComponents.append(mouse)\u000a    for thisComponent in choose_sourceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "choose_source"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = choose_sourceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *question* updates\u000a        if t >= 0.0 and question.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            question.tStart = t  # underestimates by a little under one frame\u000a            question.frameNStart = frameN  # exact frame index\u000a            question.setAutoDraw(True)\u000a        \u000a        # *self_box* updates\u000a        if t >= 0.0 and self_box.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            self_box.tStart = t  # underestimates by a little under one frame\u000a            self_box.frameNStart = frameN  # exact frame index\u000a            self_box.setAutoDraw(True)\u000a        \u000a        # *self_label* updates\u000a        if t >= 0.0 and self_label.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            self_label.tStart = t  # underestimates by a little under one frame\u000a            self_label.frameNStart = frameN  # exact frame index\u000a            self_label.setAutoDraw(True)\u000a        \u000a        # *other_box* updates\u000a        if t >= 0.0 and other_box.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            other_box.tStart = t  # underestimates by a little under one frame\u000a            other_box.frameNStart = frameN  # exact frame index\u000a            other_box.setAutoDraw(True)\u000a        \u000a        # *other_label* updates\u000a        if t >= 0.0 and other_label.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            other_label.tStart = t  # underestimates by a little under one frame\u000a            other_label.frameNStart = frameN  # exact frame index\u000a            other_label.setAutoDraw(True)\u000a        if mouse.isPressedIn(self_box, buttons=[0]):\u000a            trials.addData('choice', 'self')\u000a            choice_stats[trialtype_extended].append(1)\u000a            for thisComponent in trialComponents:\u000a                    if hasattr(thisComponent, "status"):\u000a                        thisComponent.status = FINISHED\u000a                    continueRoutine = False\u000a        elif mouse.isPressedIn(other_box, buttons=[0]):\u000a            trials.addData('choice','other')\u000a            choice_stats[trialtype_extended].append(0)\u000a            for thisComponent in trialComponents:\u000a                    if hasattr(thisComponent, "status"):\u000a                        thisComponent.status = FINISHED\u000a                    continueRoutine = False\u000a        \u000a        if self_box.contains(mouse):\u000a            self_box.fillColor = SELF_BOX_BORDER_COLOR\u000a        else:\u000a            self_box.fillColor = SELF_BOX_FILL_COLOR\u000a        \u000a        if other_box.contains(mouse):\u000a            other_box.fillColor = OTHER_BOX_BORDER_COLOR\u000a        else:\u000a            other_box.fillColor = OTHER_BOX_FILL_COLOR\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choose_sourceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "choose_source"-------\u000a    for thisComponent in choose_sourceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for trials (TrialHandler)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'trials'\u000a\u000a\u000a#------Prepare to start Routine "thankyou"-------\u000at = 0\u000athankyouClock.reset()  # clock \u000aframeN = -1\u000aroutineTimer.add(5.000000)\u000a# update component parameters for each repeat\u000a# calculate mean of stats\u000achoice_means = {}\u000afor ttype in choice_stats:\u000a    choice_means[ttype] = np.mean(choice_stats[ttype])\u000a# keep track of which components have finished\u000athankyouComponents = []\u000athankyouComponents.append(text_3)\u000afor thisComponent in thankyouComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thankyou"-------\u000acontinueRoutine = True\u000awhile continueRoutine and routineTimer.getTime() > 0:\u000a    # get current time\u000a    t = thankyouClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_3* updates\u000a    if t >= 0.0 and text_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_3.tStart = t  # underestimates by a little under one frame\u000a        text_3.frameNStart = frameN  # exact frame index\u000a        text_3.setAutoDraw(True)\u000a    if text_3.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        text_3.setAutoDraw(False)\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankyouComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "thankyou"-------\u000afor thisComponent in thankyouComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000awin.close()\u000amyDlg = gui.Dlg(title="Results", size=gui.wx.Size(-200,-200))\u000afor ttype in choice_means:\u000a    selfValue = "%.2f" % (choice_means[ttype] * 100.0)\u000a    otherValue = "%.2f" % (100 - choice_means[ttype] * 100.0)\u000a    myDlg.addText(ttype+': '+selfValue+'% self, '+otherValue+'% other')\u000amyDlg.show()\u000a\u000acore.quit()\u000a\u000aserv.stop()\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p37
sS'thisTrial'
p38
g1
(cpsychopy.data
TrialType
p39
c__builtin__
dict
p40
(dp41
S'list'
p42
Vlist6
p43
sS'amount'
p44
V0.8
p45
sS'word'
p46
Vword6.1
p47
sS'trialtype'
p48
Vspeed
p49
sS'trialtype_extended'
p50
Vslow_medium
p51
stRp52
sS'_exp'
p53
I104216496
sg10
S'trials'
p54
sg6
S'/Volumes/Macintosh HD/Users/poppe076/Desktop/source_monitoring_task/source_monitoring.py'
p55
sS'thisRepN'
p56
I0
sg14
I01
sg15
g16
sS'data'
p57
g1
(cpsychopy.data
DataHandler
p58
g40
(dp59
S'ran'
p60
cnumpy.ma.core
_mareconstruct
p61
(cnumpy.ma.core
MaskedArray
p62
cnumpy
ndarray
p63
(I0
tp64
S'b'
tRp65
(I1
(I9
I1
tg23
(S'f4'
I0
I1
tRp66
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p67
g61
(g62
g63
g64
S'b'
tRp68
(I1
(I9
I1
tg66
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x01\x01\x01\x01\x01\x01\x01\x01'
NtbstRp69
(dp70
S'isNumeric'
p71
(dp72
g60
I01
sg67
I01
ssg54
g34
sS'dataTypes'
p73
(lp74
g60
ag67
asS'dataShape'
p75
(lp76
I9
aI1
asbsS'method'
p77
S'sequential'
p78
sS'sequenceIndices'
p79
cnumpy.core.multiarray
_reconstruct
p80
(g63
(I0
tS'b'
tRp81
(I1
(I9
I1
tg23
(S'i4'
I0
I1
tRp82
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00'
tbsS'finished'
p83
I00
sS'nReps'
p84
I1
sS'nRemaining'
p85
I8
sS'trialList'
p86
(lp87
g52
ag1
(g39
g40
(dp88
g42
Vlist5
p89
sg44
V0.9
p90
sg46
Vword5.1
p91
sg48
Vspeed
p92
sg50
Vslow_small
p93
stRp94
ag1
(g39
g40
(dp95
g42
Vlist7
p96
sg44
V0.7
p97
sg46
Vword7.1
p98
sg48
Vspeed
p99
sg50
Vslow_large
p100
stRp101
ag1
(g39
g40
(dp102
g42
Vlist1
p103
sg44
V-1.5
p104
sg46
Vword1.1
p105
sg48
Vpitch
p106
sg50
Vpitch_lower_large
p107
stRp108
ag1
(g39
g40
(dp109
g42
Vlist8
p110
sg44
V1.5
p111
sg46
Vword8.1
p112
sg48
Vpitch
p113
sg50
Vpitch_higher_small
p114
stRp115
ag1
(g39
g40
(dp116
g42
Vlist9
p117
sg44
V-1.5
p118
sg46
Vword9.1
p119
sg48
Vpitch
p120
sg50
Vpitch_lower_small
p121
stRp122
ag1
(g39
g40
(dp123
g42
Vlist2
p124
sg44
V2
sg46
Vword2.1
p125
sg48
Vpitch
p126
sg50
Vpitch_higher_large
p127
stRp128
ag1
(g39
g40
(dp129
g42
Vlist4
p130
sg44
Vunmodified
p131
sg46
Vword4.1
p132
sg48
Vunmodified
p133
sg50
Vunmodified
p134
stRp135
ag1
(g39
g40
(dp136
g42
Vlist3
p137
sg44
Vunmodified
p138
sg46
Vword3.1
p139
sg48
Vunmodified
p140
sg50
Vunmodified
p141
stRp142
asS'seed'
p143
NsS'thisIndex'
p144
g22
(g82
S'\x00\x00\x00\x00'
tRp145
sS'thisN'
p146
I0
sS'thisTrialN'
p147
I0
sS'nTotal'
p148
I9
sS'_warnUseOfNext'
p149
I01
sbasS'saveWideText'
p150
I01
sS'thisEntry'
p151
(dp152
sS'version'
p153
S''
sS'_paramNamesSoFar'
p154
(lp155
sS'entries'
p156
(lp157
sS'loops'
p158
(lp159
g34
asS'savePickle'
p160
I01
sb.