ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
V/Volumes/Macintosh HD/Users/poppe076/Desktop/source_monitoring_task/data/ok_source_monitoring_2015_Feb_05_1358
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'source_monitoring'
p11
sS'dataNames'
p12
(lp13
S'choice'
p14
asS'autoLog'
p15
I01
sS'extraInfo'
p16
(dp17
S'participant'
p18
Vok
p19
sS'listOrder'
p20
(lp21
V1
aV1
aV1
aV1
aV1
aV1
aV1
aV1
aV8
asS'frameRate'
p22
cnumpy.core.multiarray
scalar
p23
(cnumpy
dtype
p24
(S'f8'
I0
I1
tRp25
(I3
S'<'
NNNI-1
I-1
I0
tbS'O\xd8\xb7*\x8b\xf1M@'
tRp26
sS'expName'
p27
g11
sS'date'
p28
V2015_Feb_05_1358
p29
sS'listMethod'
p30
Vset your own
p31
ssS'loopsUnfinished'
p32
(lp33
sS'saveWideText'
p34
I01
sS'thisEntry'
p35
(dp36
sS'version'
p37
S''
sS'_paramNamesSoFar'
p38
(lp39
S'word'
p40
aS'amount'
p41
aS'list'
p42
aS'trialtype'
p43
aS'trialtype_extended'
p44
asS'entries'
p45
(lp46
(dp47
S'trials.thisIndex'
p48
g23
(g24
(S'i4'
I0
I1
tRp49
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00\x00\x00\x00'
tRp50
sg22
g26
sg40
Vword1.1
p51
sS'trials.thisRepN'
p52
I0
sg42
Vlist1
p53
sg44
Vslow_small
p54
sS'trials.thisN'
p55
I0
sg30
g31
sg41
V0.9
p56
sg27
g11
sS'trials.thisTrialN'
p57
I0
sg43
Vspeed
p58
sg20
g21
sg28
g29
sg18
g19
sg14
S'self'
p59
sa(dp60
S'trials.thisIndex'
p61
g23
(g49
S'\x01\x00\x00\x00'
tRp62
sg22
g26
sg40
Vword1.1
p63
sS'trials.thisRepN'
p64
I0
sg42
Vlist1
p65
sg44
Vpitch_higher_small
p66
sS'trials.thisN'
p67
I1
sg30
g31
sg41
V1.5
p68
sg27
g11
sS'trials.thisTrialN'
p69
I1
sg43
Vpitch
p70
sg20
g21
sg28
g29
sg18
g19
sg14
g59
sa(dp71
S'trials.thisIndex'
p72
g23
(g49
S'\x02\x00\x00\x00'
tRp73
sg22
g26
sg40
Vword1.1
p74
sS'trials.thisRepN'
p75
I0
sg42
Vlist1
p76
sg44
Vpitch_higher_large
p77
sS'trials.thisN'
p78
I2
sg30
g31
sg41
V2
sg27
g11
sS'trials.thisTrialN'
p79
I2
sg43
Vpitch
p80
sg20
g21
sg28
g29
sg18
g19
sg14
g59
sa(dp81
S'trials.thisIndex'
p82
g23
(g49
S'\x03\x00\x00\x00'
tRp83
sg22
g26
sg40
Vword8.1
p84
sS'trials.thisRepN'
p85
I0
sg42
Vlist8
p86
sg44
Vpitch_lower_large
p87
sS'trials.thisN'
p88
I3
sg30
g31
sg41
V-1.5
p89
sg27
g11
sS'trials.thisTrialN'
p90
I3
sg43
Vpitch
p91
sg20
g21
sg28
g29
sg18
g19
sg14
S'other'
p92
sa(dp93
S'trials.thisIndex'
p94
g23
(g49
S'\x04\x00\x00\x00'
tRp95
sg22
g26
sg40
Vword1.1
p96
sS'trials.thisRepN'
p97
I0
sg42
Vlist1
p98
sg44
Vslow_medium
p99
sS'trials.thisN'
p100
I4
sg30
g31
sg41
V0.8
p101
sg27
g11
sS'trials.thisTrialN'
p102
I4
sg43
Vspeed
p103
sg20
g21
sg28
g29
sg18
g19
sg14
g59
sa(dp104
S'trials.thisIndex'
p105
g23
(g49
S'\x05\x00\x00\x00'
tRp106
sg22
g26
sg40
Vword1.1
p107
sS'trials.thisRepN'
p108
I0
sg42
Vlist1
p109
sg44
Vunmodified
p110
sS'trials.thisN'
p111
I5
sg30
g31
sg41
Vunmodified
p112
sg27
g11
sS'trials.thisTrialN'
p113
I5
sg43
Vunmodified
p114
sg20
g21
sg28
g29
sg18
g19
sg14
g92
sa(dp115
S'trials.thisIndex'
p116
g23
(g49
S'\x06\x00\x00\x00'
tRp117
sg22
g26
sg40
Vword1.1
p118
sS'trials.thisRepN'
p119
I0
sg42
Vlist1
p120
sg44
Vslow_large
p121
sS'trials.thisN'
p122
I6
sg30
g31
sg41
V0.7
p123
sg27
g11
sS'trials.thisTrialN'
p124
I6
sg43
Vspeed
p125
sg20
g21
sg28
g29
sg18
g19
sg14
g59
sa(dp126
S'trials.thisIndex'
p127
g23
(g49
S'\x07\x00\x00\x00'
tRp128
sg22
g26
sg40
Vword1.1
p129
sS'trials.thisRepN'
p130
I0
sg42
Vlist1
p131
sg44
Vpitch_lower_small
p132
sS'trials.thisN'
p133
I7
sg30
g31
sg41
V-1.5
p134
sg27
g11
sS'trials.thisTrialN'
p135
I7
sg43
Vpitch
p136
sg20
g21
sg28
g29
sg18
g19
sg14
g59
sa(dp137
S'trials.thisIndex'
p138
g23
(g49
S'\x08\x00\x00\x00'
tRp139
sg22
g26
sg40
Vword1.1
p140
sS'trials.thisRepN'
p141
I0
sg42
Vlist1
p142
sg44
Vunmodified
p143
sS'trials.thisN'
p144
I8
sg30
g31
sg41
Vunmodified
p145
sg27
g11
sS'trials.thisTrialN'
p146
I8
sg43
Vunmodified
p147
sg20
g21
sg28
g29
sg18
g19
sg14
g92
sasS'loops'
p148
(lp149
g1
(cpsychopy.data
TrialHandler
p150
g3
NtRp151
(dp152
S'origin'
p153
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.03), Thu Feb  5 12:37:35 2015\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'source_monitoring'  # from the Builder filename that created this script\u000aexpInfo = {}\u000a\u000amyDlg = gui.Dlg(title=expName, size=gui.wx.Size(-1,-75))\u000amyDlg.addField(u'participant: ', u'')\u000amyDlg.addField('word lists: ', choices=['random','set your own']) \u000amyDlg.show()\u000aif myDlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['participant'] = myDlg.data[0]\u000aexpInfo['listMethod'] = myDlg.data[1]\u000aprint expInfo['listMethod']\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a\u000aif expInfo['listMethod']=='set your own':\u000a    myDlg2 = gui.Dlg(title='Set Word Lists')\u000a    conditions = ['unmodified 1', 'unmodified 2', 'slowed - small', 'slowed - medium', 'slowed - large', 'pitch - higher - small', 'pitch - higher - large', 'pitch - lower - small', 'pitch - lower - large']\u000a    for cNum in range(len(conditions)):\u000a        myDlg2.addField(conditions[cNum], choices=[1,2,3,4,5,6,7,8,9], initial=cNum+1)\u000a    myDlg2.show()\u000a    if myDlg2.OK == False: core.quit()  # user pressed cancel\u000a    expInfo['listOrder'] = myDlg2.data\u000a    \u000afrom psychopy import visual\u000a\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1440, 900), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[-1,-1,-1], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "initialize_code"\u000ainitialize_codeClock = core.Clock()\u000afrom psychopy import gui\u000afrom pyo import *\u000aimport math, sys, csv, random\u000afrom collections import OrderedDict\u000aserv = Server().boot()\u000a\u000a## SETTINGS ##\u000a\u000aSPEED_SMALL_AMOUNT = .9   #0.975\u000aSPEED_MEDIUM_AMOUNT = .8  #0.95\u000aSPEED_LARGE_AMOUNT = .7   #0.925\u000aPITCH_HIGHER_SMALL_AMOUNT = 1.5    #0.5\u000aPITCH_HIGHER_LARGE_AMOUNT = 2    #1.0\u000aPITCH_LOWER_SMALL_AMOUNT = -1.5 #-0.5\u000aPITCH_LOWER_LARGE_AMOUNT = -2 #-1.0\u000a\u000aSELF_BOX_FILL_COLOR = '#A6A9FF'\u000aSELF_BOX_BORDER_COLOR = '#3E45FA'\u000aOTHER_BOX_FILL_COLOR = '#FFFCA6'\u000aOTHER_BOX_BORDER_COLOR = '#FAF33E'\u000a\u000a## END SETTINGS ##\u000a\u000a\u000a\u000a\u000a\u000a# initialize this variable - it keeps track of whether \u000a# the subject is finished speaking during a time stretch trial\u000afinished = True\u000a\u000a##########################################################\u000a### read in the original word list file and save word list file for this subject\u000a##########################################################\u000a# container array for file contents\u000aorig_words = []\u000a# read csv file with the original word lists (in same directory as this experiment script)\u000awith open('orig_words.csv', 'rU') as csvfile:\u000a    test = csv.reader(csvfile)\u000a    for i in test:\u000a        orig_words.append(i)\u000a\u000a# depending on experiementer's selection at run time, either randomize word lists or\u000a# use the experimenter's order\u000adef fixList(x):\u000a    return int(x)-1\u000a\u000aif expInfo['listMethod']=='set your own':\u000a    assignment_order = map(fixList, expInfo['listOrder'])\u000aelse:\u000a    assignment_order = random.sample([0,1,2,3,4,5,6,7,8], 9)\u000a\u000a# initialize word containers for the trial types\u000aunmodified_words1 = []\u000aunmodified_words2 = []\u000aslowed_small_words = []\u000aslowed_medium_words = []\u000aslowed_large_words = []\u000apitch_higher_small_words = []\u000apitch_higher_large_words = []\u000apitch_lower_small_words = []\u000apitch_lower_large_words = []\u000a\u000a# assign words to those containers\u000afor row in orig_words:\u000a    unmodified_words1.append(row[assignment_order[0]])\u000a    unmodified_words2.append(row[assignment_order[1]])\u000a    slowed_small_words.append(row[assignment_order[2]])\u000a    slowed_medium_words.append(row[assignment_order[3]])\u000a    slowed_large_words.append(row[assignment_order[4]])\u000a    pitch_higher_small_words.append(row[assignment_order[5]])\u000a    pitch_higher_large_words.append(row[assignment_order[6]])\u000a    pitch_lower_small_words.append(row[assignment_order[7]])\u000a    pitch_lower_large_words.append(row[assignment_order[8]])\u000a\u000a# this will be the name of the wordlist csv file for this subject\u000awordlist_filename = filename+'_wordlist.csv'\u000aresults_filename = filename+'_summarized_results.csv'\u000a\u000a# build a big array with all the words and also attach trialtype and amount data,\u000a# like this: [word, trialtype, trialtype_extended, amount, list]\u000amaster_list = []\u000a\u000a# add the words (CAREFUL! This assumes all of the categories are of equal length)\u000afor word_index in range(len(slowed_small_words)):\u000a    if word_index == 0:\u000a        continue\u000a    master_list.append([unmodified_words1[word_index], 'unmodified', 'unmodified',            'unmodified',                                        unmodified_words1[0]])\u000a    master_list.append([unmodified_words2[word_index], 'unmodified', 'unmodified',            'unmodified',                                        unmodified_words2[0]])\u000a    master_list.append([slowed_small_words[word_index],         'speed', 'slow_small',           SPEED_SMALL_AMOUNT,                slowed_small_words[0]])\u000a    master_list.append([slowed_medium_words[word_index],     'speed', 'slow_medium',       SPEED_MEDIUM_AMOUNT,             slowed_medium_words[0]])\u000a    master_list.append([slowed_large_words[word_index],         'speed', 'slow_large',             SPEED_LARGE_AMOUNT,               slowed_large_words[0]])\u000a    master_list.append([pitch_higher_small_words[word_index], 'pitch',  'pitch_higher_small', PITCH_HIGHER_SMALL_AMOUNT,  pitch_higher_small_words[0]])\u000a    master_list.append([pitch_higher_large_words[word_index], 'pitch',  'pitch_higher_large',  PITCH_HIGHER_LARGE_AMOUNT, pitch_higher_large_words[0]])\u000a    master_list.append([pitch_lower_small_words[word_index],  'pitch',  'pitch_lower_small',   PITCH_LOWER_SMALL_AMOUNT,  pitch_lower_small_words[0]])\u000a    master_list.append([pitch_lower_large_words[word_index],  'pitch',  'pitch_lower_large',    PITCH_LOWER_SMALL_AMOUNT,  pitch_lower_large_words[0]])\u000a\u000a# now randomize the list\u000arandom.shuffle(master_list)\u000a\u000a# save csv file to disk\u000awith open(wordlist_filename,'wb') as w:\u000a    writer=csv.writer(w)\u000a    writer.writerow(['word','trialtype', 'trialtype_extended', 'amount', 'list'])\u000a    for row in master_list:\u000a        writer.writerow(row)\u000a\u000a# create container for stats\u000achoice_stats = OrderedDict()\u000achoice_stats['unmodified'] = []\u000achoice_stats['slow_small'] = []\u000achoice_stats['slow_medium'] = []\u000achoice_stats['slow_large'] = []\u000achoice_stats['pitch_higher_small'] = []\u000achoice_stats['pitch_higher_large'] = []\u000achoice_stats['pitch_lower_small'] = []\u000achoice_stats['pitch_lower_large'] = []\u000a\u000a# Initialize components for Routine "instructions"\u000ainstructionsClock = core.Clock()\u000atext_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a    text='Instructions will go here.',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aserv.start()\u000amic = Input(chnl=0)\u000atext = visual.TextStim(win=win, ori=0, name='text',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "choose_source"\u000achoose_sourceClock = core.Clock()\u000aquestion = visual.TextStim(win=win, ori=0, name='question',\u000a    text='Whose voice did you hear?',    font='Arial',\u000a    pos=[0, .5], height=0.1, wrapWidth=2,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000aself_box = visual.Rect(win=win, name='self_box',\u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-.5, -.5],\u000a    lineWidth=5, lineColor=SELF_BOX_BORDER_COLOR, lineColorSpace='rgb',\u000a    fillColor=SELF_BOX_FILL_COLOR, fillColorSpace='rgb',\u000a    opacity=1,interpolate=True)\u000aself_label = visual.TextStim(win=win, ori=0, name='self_label',\u000a    text='Mine',    font='Arial',\u000a    pos=[-.5, -.5], height=0.1, wrapWidth=None,\u000a    color='black', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000aother_box = visual.Rect(win=win, name='other_box',\u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[.5, -.5],\u000a    lineWidth=5, lineColor=OTHER_BOX_BORDER_COLOR, lineColorSpace='rgb',\u000a    fillColor=OTHER_BOX_FILL_COLOR, fillColorSpace='rgb',\u000a    opacity=1,interpolate=True)\u000aother_label = visual.TextStim(win=win, ori=0, name='other_label',\u000a    text='Other',    font='Arial',\u000a    pos=[.5, -.5], height=0.1, wrapWidth=None,\u000a    color='black', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000amouse = event.Mouse(win=win)\u000ax, y = [None, None]\u000a\u000a\u000a# Initialize components for Routine "thankyou"\u000athankyouClock = core.Clock()\u000atext_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a    text='Thank you for participating!',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a\u000a# Initialize components for Routine "display_results"\u000adisplay_resultsClock = core.Clock()\u000aresults_text = visual.TextStim(win=win, ori=0, name='results_text',\u000a    text='default text',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=2,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "initialize_code"-------\u000at = 0\u000ainitialize_codeClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000a\u000a# keep track of which components have finished\u000ainitialize_codeComponents = []\u000afor thisComponent in initialize_codeComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "initialize_code"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = initialize_codeClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in initialize_codeComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "initialize_code"-------\u000afor thisComponent in initialize_codeComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a\u000a#------Prepare to start Routine "instructions"-------\u000at = 0\u000ainstructionsClock.reset()  # clock \u000aframeN = -1\u000aroutineTimer.add(5.000000)\u000a# update component parameters for each repeat\u000a# keep track of which components have finished\u000ainstructionsComponents = []\u000ainstructionsComponents.append(text_4)\u000afor thisComponent in instructionsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instructions"-------\u000acontinueRoutine = True\u000awhile continueRoutine and routineTimer.getTime() > 0:\u000a    # get current time\u000a    t = instructionsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_4* updates\u000a    if t >= 0.0 and text_4.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_4.tStart = t  # underestimates by a little under one frame\u000a        text_4.frameNStart = frameN  # exact frame index\u000a        text_4.setAutoDraw(True)\u000a    if text_4.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        text_4.setAutoDraw(False)\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instructions"-------\u000afor thisComponent in instructionsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atrials = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(wordlist_filename),\u000a    seed=None, name='trials')\u000athisExp.addLoop(trials)  # add the loop to the experiment\u000athisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000aif thisTrial != None:\u000a    for paramName in thisTrial.keys():\u000a        exec(paramName + '= thisTrial.' + paramName)\u000a\u000afor thisTrial in trials:\u000a    currentLoop = trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(11.000000)\u000a    # update component parameters for each repeat\u000a    if(trialtype == "pitch"): # pitch trial\u000a        b = Harmonizer(mic, transpo=float(amount))\u000a        c = Gate(b, thresh=-90, falltime=0.02, lookahead=20.0).mix(2).out()\u000a        d = Follower2(b)\u000a        talkThresh = .08\u000a        talkStarted = False\u000a        stoppedTalking = False\u000a        stopTime = 100\u000a    elif(trialtype == 'speed'): # speed trial\u000a        finished = 'not finished'\u000a        playback_speed = float(amount)\u000a        dur = 2\u000a        if playback_speed == 0:\u000a            playback_speed = pow(10,-100)\u000a    \u000a        def start():\u000a            rec.play()\u000a            a.play().out()\u000a            tf.stop()\u000a    \u000a        def stop():\u000a            k.stop()\u000a            global finished\u000a            finished = 'finished'\u000a            a.stop()\u000a            a.reset()\u000a            tf.play()\u000a    \u000a        tab = NewTable(dur, chnls=2)\u000a        transpo_to_normal = math.log(1.0 / playback_speed, 2) * 12\u000a        j = Harmonizer(mic, transpo=transpo_to_normal).mix(2)\u000a        k = Gate(j, thresh=-70, falltime=0.02, lookahead=20.0)\u000a        rec = TableRec(k, tab)\u000a        a = TableRead(table=tab, freq=playback_speed/dur).stop()\u000a        env = Follower(mic)\u000a        th = Thresh(env, .1)\u000a        tf = TrigFunc(th, start)\u000a        tr = TrigFunc(rec['trig'], stop)\u000a    else: # unmodified trial\u000a        b = Gate(mic, thresh=-90, falltime=0.02, lookahead=20.0).mix(2).out()\u000a        d = Follower2(mic)\u000a        talkThresh = .08\u000a        talkStarted = False\u000a        stoppedTalking = False\u000a        stopTime = 100\u000a    text.setText(word)\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(text)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        if(trialtype == "pitch" or trialtype == "unmodified"):\u000a            if d.get() > talkThresh:\u000a                    talkStarted = True\u000a        \u000a            if talkStarted and not stoppedTalking:\u000a                if d.get() < talkThresh:\u000a                    stoppedTalking = True\u000a                    stopTime = globalClock.getTime() + 1\u000a        \u000a            if stoppedTalking and globalClock.getTime() >= stopTime:\u000a                b.stop()\u000a                for thisComponent in trialComponents:\u000a                    if hasattr(thisComponent, "status"):\u000a                        thisComponent.status = FINISHED\u000a                    continueRoutine = False\u000a        else:\u000a            if(finished == 'finished'):\u000a                for thisComponent in trialComponents:\u000a                    if hasattr(thisComponent, "status"):\u000a                        thisComponent.status = FINISHED\u000a                    continueRoutine = False\u000a        \u000a        # *text* updates\u000a        if t >= 1 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        if text.status == STARTED and t >= (1 + (10-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    \u000a    #------Prepare to start Routine "choose_source"-------\u000a    t = 0\u000a    choose_sourceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # setup some python lists for storing info about the mouse\u000a    \u000a    # keep track of which components have finished\u000a    choose_sourceComponents = []\u000a    choose_sourceComponents.append(question)\u000a    choose_sourceComponents.append(self_box)\u000a    choose_sourceComponents.append(self_label)\u000a    choose_sourceComponents.append(other_box)\u000a    choose_sourceComponents.append(other_label)\u000a    choose_sourceComponents.append(mouse)\u000a    for thisComponent in choose_sourceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "choose_source"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = choose_sourceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *question* updates\u000a        if t >= 0.0 and question.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            question.tStart = t  # underestimates by a little under one frame\u000a            question.frameNStart = frameN  # exact frame index\u000a            question.setAutoDraw(True)\u000a        \u000a        # *self_box* updates\u000a        if t >= 0.0 and self_box.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            self_box.tStart = t  # underestimates by a little under one frame\u000a            self_box.frameNStart = frameN  # exact frame index\u000a            self_box.setAutoDraw(True)\u000a        \u000a        # *self_label* updates\u000a        if t >= 0.0 and self_label.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            self_label.tStart = t  # underestimates by a little under one frame\u000a            self_label.frameNStart = frameN  # exact frame index\u000a            self_label.setAutoDraw(True)\u000a        \u000a        # *other_box* updates\u000a        if t >= 0.0 and other_box.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            other_box.tStart = t  # underestimates by a little under one frame\u000a            other_box.frameNStart = frameN  # exact frame index\u000a            other_box.setAutoDraw(True)\u000a        \u000a        # *other_label* updates\u000a        if t >= 0.0 and other_label.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            other_label.tStart = t  # underestimates by a little under one frame\u000a            other_label.frameNStart = frameN  # exact frame index\u000a            other_label.setAutoDraw(True)\u000a        if mouse.isPressedIn(self_box, buttons=[0]):\u000a            trials.addData('choice', 'self')\u000a            choice_stats[trialtype_extended].append(1)\u000a            for thisComponent in trialComponents:\u000a                    if hasattr(thisComponent, "status"):\u000a                        thisComponent.status = FINISHED\u000a                    continueRoutine = False\u000a        elif mouse.isPressedIn(other_box, buttons=[0]):\u000a            trials.addData('choice','other')\u000a            choice_stats[trialtype_extended].append(0)\u000a            for thisComponent in trialComponents:\u000a                    if hasattr(thisComponent, "status"):\u000a                        thisComponent.status = FINISHED\u000a                    continueRoutine = False\u000a        \u000a        if self_box.contains(mouse):\u000a            self_box.fillColor = SELF_BOX_BORDER_COLOR\u000a        else:\u000a            self_box.fillColor = SELF_BOX_FILL_COLOR\u000a        \u000a        if other_box.contains(mouse):\u000a            other_box.fillColor = OTHER_BOX_BORDER_COLOR\u000a        else:\u000a            other_box.fillColor = OTHER_BOX_FILL_COLOR\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choose_sourceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "choose_source"-------\u000a    for thisComponent in choose_sourceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for trials (TrialHandler)\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'trials'\u000a\u000a\u000a#------Prepare to start Routine "thankyou"-------\u000at = 0\u000athankyouClock.reset()  # clock \u000aframeN = -1\u000aroutineTimer.add(5.000000)\u000a# update component parameters for each repeat\u000a# calculate mean of stats\u000achoice_means = OrderedDict()\u000afor ttype in choice_stats:\u000a    choice_means[ttype] = np.mean(choice_stats[ttype])\u000a\u000a\u000a# keep track of which components have finished\u000athankyouComponents = []\u000athankyouComponents.append(text_3)\u000afor thisComponent in thankyouComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "thankyou"-------\u000acontinueRoutine = True\u000awhile continueRoutine and routineTimer.getTime() > 0:\u000a    # get current time\u000a    t = thankyouClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *text_3* updates\u000a    if t >= 0.0 and text_3.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        text_3.tStart = t  # underestimates by a little under one frame\u000a        text_3.frameNStart = frameN  # exact frame index\u000a        text_3.setAutoDraw(True)\u000a    if text_3.status == STARTED and t >= (0.0 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a        text_3.setAutoDraw(False)\u000a    \u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in thankyouComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "thankyou"-------\u000afor thisComponent in thankyouComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a#win.close()\u000a#myDlg = gui.Dlg(title="Results", size=gui.wx.Size(-200,-200))\u000a#for ttype in choice_means:\u000a#    selfValue = "%.2f" % (choice_means[ttype] * 100.0)\u000a#    otherValue = "%.2f" % (100 - choice_means[ttype] * 100.0)\u000a#    myDlg.addText(ttype+': '+selfValue+'% self, '+otherValue+'% other')\u000a#myDlg.show()\u000a\u000a#core.quit()\u000a\u000aresults = '\u005cn\u005cr'\u000afor ttype in choice_means:\u000a    selfValue = "%.2f" % (choice_means[ttype] * 100.0)\u000a    otherValue = "%.2f" % (100 - choice_means[ttype] * 100.0)\u000a    results += ttype+': '+selfValue+'% self, '+otherValue+'% other'+'\u005cn\u005cr'\u000a\u000a# write summarized results to csv file\u000awith open(results_filename,'wb') as w:\u000a    writer=csv.writer(w)\u000a    writer.writerow(['trialtype', 'percent_self_choices', 'percent_other_choices'])\u000a    for row in choice_means:\u000a        selfValue = "%.2f" % (choice_means[ttype] * 100.0)\u000a        otherValue = "%.2f" % (100 - choice_means[ttype] * 100.0)\u000a        writer.writerow([row, selfValue, otherValue])\u000a\u000a#------Prepare to start Routine "display_results"-------\u000at = 0\u000adisplay_resultsClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aresults_text.setText(results)\u000akey_resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000akey_resp_2.status = NOT_STARTED\u000a# keep track of which components have finished\u000adisplay_resultsComponents = []\u000adisplay_resultsComponents.append(results_text)\u000adisplay_resultsComponents.append(key_resp_2)\u000afor thisComponent in display_resultsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "display_results"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = display_resultsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *results_text* updates\u000a    if t >= 0.0 and results_text.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        results_text.tStart = t  # underestimates by a little under one frame\u000a        results_text.frameNStart = frameN  # exact frame index\u000a        results_text.setAutoDraw(True)\u000a    \u000a    # *key_resp_2* updates\u000a    if t >= 0.0 and key_resp_2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        key_resp_2.tStart = t  # underestimates by a little under one frame\u000a        key_resp_2.frameNStart = frameN  # exact frame index\u000a        key_resp_2.status = STARTED\u000a        # keyboard checking is just starting\u000a        event.clearEvents(eventType='keyboard')\u000a    if key_resp_2.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['esc'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in display_resultsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "display_results"-------\u000afor thisComponent in display_resultsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a\u000aserv.stop()\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p154
sS'thisTrial'
p155
(lp156
sS'_exp'
p157
I105335184
sg10
S'trials'
p158
sg6
S'/Volumes/Macintosh HD/Users/poppe076/Desktop/source_monitoring_task/source_monitoring.py'
p159
sS'thisRepN'
p160
I1
sg15
I01
sg16
g17
sS'data'
p161
g1
(cpsychopy.data
DataHandler
p162
c__builtin__
dict
p163
(dp164
S'ran'
p165
cnumpy.ma.core
_mareconstruct
p166
(cnumpy.ma.core
MaskedArray
p167
cnumpy
ndarray
p168
(I0
tp169
S'b'
tRp170
(I1
(I9
I1
tg24
(S'f4'
I0
I1
tRp171
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p172
g166
(g167
g168
g169
S'b'
tRp173
(I1
(I9
I1
tg171
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@\x00\x00\xa0@\x00\x00\xc0@\x00\x00\xe0@\x00\x00\x00A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg14
cnumpy.core.multiarray
_reconstruct
p174
(g168
(I0
tS'b'
tRp175
(I1
(I9
I1
tg24
(S'O4'
I0
I1
tRp176
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp177
g59
ag59
ag59
ag92
ag59
ag92
ag59
ag59
ag92
atbstRp178
(dp179
S'isNumeric'
p180
(dp181
g165
I01
sg172
I01
sg14
I00
ssg158
g151
sS'dataTypes'
p182
(lp183
g165
ag172
ag14
asS'dataShape'
p184
(lp185
I9
aI1
asbsS'method'
p186
S'sequential'
p187
sS'sequenceIndices'
p188
g174
(g168
(I0
tS'b'
tRp189
(I1
(I9
I1
tg49
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00'
tbsS'finished'
p190
I01
sS'nReps'
p191
I1
sS'nRemaining'
p192
I-1
sS'trialList'
p193
(lp194
g1
(cpsychopy.data
TrialType
p195
g163
(dp196
g42
g53
sg41
g56
sg40
g51
sg43
g58
sg44
g54
stRp197
ag1
(g195
g163
(dp198
g42
g65
sg41
g68
sg40
g63
sg43
g70
sg44
g66
stRp199
ag1
(g195
g163
(dp200
g42
g76
sg41
V2
sg40
g74
sg43
g80
sg44
g77
stRp201
ag1
(g195
g163
(dp202
g42
g86
sg41
g89
sg40
g84
sg43
g91
sg44
g87
stRp203
ag1
(g195
g163
(dp204
g42
g98
sg41
g101
sg40
g96
sg43
g103
sg44
g99
stRp205
ag1
(g195
g163
(dp206
g42
g109
sg41
g112
sg40
g107
sg43
g114
sg44
g110
stRp207
ag1
(g195
g163
(dp208
g42
g120
sg41
g123
sg40
g118
sg43
g125
sg44
g121
stRp209
ag1
(g195
g163
(dp210
g42
g131
sg41
g134
sg40
g129
sg43
g136
sg44
g132
stRp211
ag1
(g195
g163
(dp212
g42
g142
sg41
g145
sg40
g140
sg43
g147
sg44
g143
stRp213
asS'seed'
p214
NsS'thisIndex'
p215
g139
sS'thisN'
p216
I9
sS'thisTrialN'
p217
I0
sS'nTotal'
p218
I9
sS'_warnUseOfNext'
p219
I01
sbasS'savePickle'
p220
I01
sb.